/* automatically generated by rust-bindgen 0.69.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ACC_CAL_RESULT_DATA_SIZE: u32 = 192;
pub const ACC_MAX_NUM_SUBSWEEPS: u32 = 4;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const PRIsensor_id: &[u8; 2] = b"u\0";
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const ACC_HAL_SPI_TRANSFER_SIZE_REQUIRED: u32 = 16;
pub const ACC_RSS_ASSEMBLY_TEST_MIN_BUFFER_SIZE: u32 = 4096;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __suseconds64_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " The result from a completed calibration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_cal_result_t {
    pub data: [u8; 192usize],
}
#[test]
fn bindgen_test_layout_acc_cal_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_cal_result_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_cal_result_t>(),
        192usize,
        concat!("Size of: ", stringify!(acc_cal_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_cal_result_t>(),
        1usize,
        concat!("Alignment of ", stringify!(acc_cal_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_cal_result_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Information about calibration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_cal_info_t {
    pub temperature: i16,
}
#[test]
fn bindgen_test_layout_acc_cal_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_cal_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_cal_info_t>(),
        2usize,
        concat!("Size of: ", stringify!(acc_cal_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_cal_info_t>(),
        2usize,
        concat!("Alignment of ", stringify!(acc_cal_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_cal_info_t),
            "::",
            stringify!(temperature)
        )
    );
}
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_1: acc_config_profile_t = 1;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_2: acc_config_profile_t = 2;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_3: acc_config_profile_t = 3;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_4: acc_config_profile_t = 4;
#[doc = " The profile with the lowest depth resolution and highest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_5: acc_config_profile_t = 5;
#[doc = " @brief Profile\n\n Each profile consists of a number of settings for the sensor that configures the RX and TX paths.\n Lower profiles have higher depth resolution while higher profiles have higher radar loop gain."]
pub type acc_config_profile_t = cty::c_uint;
#[doc = " The deepest state where as much of the sensor hardware is shut down."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_DEEP_SLEEP: acc_config_idle_state_t = 0;
#[doc = " The deepest state where as much of the sensor hardware is shut down."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_SLEEP: acc_config_idle_state_t = 1;
#[doc = " The shallowest state where most of the sensor hardware is kept on."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_READY: acc_config_idle_state_t = 2;
#[doc = " @brief Idle state\n\n Idle state 'DEEP_SLEEP' is the deepest state where as much of the sensor hardware as\n possible is shut down and idle state 'READY' is the shallowest state where most of the sensor\n hardware is kept on.\n\n DEEP_SLEEP is the slowest to transition from while READY is the fastest.\n"]
pub type acc_config_idle_state_t = cty::c_uint;
#[doc = " 19.5 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_19_5_MHZ: acc_config_prf_t = 0;
#[doc = " 15.6 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_15_6_MHZ: acc_config_prf_t = 1;
#[doc = " 13.0 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_13_0_MHZ: acc_config_prf_t = 2;
#[doc = " 8.7 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_8_7_MHZ: acc_config_prf_t = 3;
#[doc = " 6.5 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_6_5_MHZ: acc_config_prf_t = 4;
#[doc = " 5.2 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_5_2_MHZ: acc_config_prf_t = 5;
#[doc = " @brief Pulse Repetition Frequency\n\n Pulse Repetition Frequency, PRF, is the frequency at\n which pulses are sent out from the radar system. The\n measurement time is approximately proportional to the\n PRF. The higher the PRF, the shorter the measurement time.\n\n This parameter sets the Maximum Measurable Distance, MMD,\n that can be achieved. MMD is the maximum value for the end point,\n i.e.,the start point + (number of points * step length).\n For example, an MMD of 7.0 m means that the range cannot\n be set further out than 7.0 m.\n\n It also sets the Maximum Unambiguous Range, MUR, that can be achieved.\n MUR is the maximum distance at which an object can be located to guarantee\n that its reflection corresponds to the most recent transmitted pulse.\n Objects farther away than the MUR may fold into the measured range.\n For example, with a MUR of 11.5 m, an object at 13.5 m could become\n visible at 2 m.\n\n | PRF Setting              |      PRF |    MMD |    MUR |\n |-------------------------:|---------:|-------:|-------:|\n | ACC_CONFIG_PRF_19_5_MHZ* | 19.5 MHz |  3.1 m |  7.7 m |\n | ACC_CONFIG_PRF_15_6_MHZ  | 15.6 MHz |  5.1 m |  9.6 m |\n | ACC_CONFIG_PRF_13_0_MHZ  | 13.0 MHz |  7.0 m | 11.5 m |\n | ACC_CONFIG_PRF_8_7_MHZ   |  8.7 MHz | 12.7 m | 17.3 m |\n | ACC_CONFIG_PRF_6_5_MHZ   |  6.5 MHz | 18.5 m | 23.1 m |\n | ACC_CONFIG_PRF_5_2_MHZ   |  5.2 MHz | 24.3 m | 28.8 m |\n\n *19.5MHz is only available for profile 1."]
pub type acc_config_prf_t = cty::c_uint;
pub type __gwchar_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> uintmax_t;
}
#[doc = " @brief Type representing a sensor ID"]
pub type acc_sensor_id_t = u32;
#[doc = " ERROR log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_ERROR: acc_log_level_t = 0;
#[doc = " WARNING log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_WARNING: acc_log_level_t = 1;
#[doc = " INFO log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_INFO: acc_log_level_t = 2;
#[doc = " VERBOSE log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_VERBOSE: acc_log_level_t = 3;
#[doc = " DEBUG log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_DEBUG: acc_log_level_t = 4;
#[doc = " @brief This enum represents the different log levels for RSS"]
pub type acc_log_level_t = cty::c_uint;
#[doc = " @brief Data type for interger-based representation of complex numbers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_int16_complex_t {
    pub real: i16,
    pub imag: i16,
}
#[test]
fn bindgen_test_layout_acc_int16_complex_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_int16_complex_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_int16_complex_t>(),
        4usize,
        concat!("Size of: ", stringify!(acc_int16_complex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_int16_complex_t>(),
        2usize,
        concat!("Alignment of ", stringify!(acc_int16_complex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_int16_complex_t),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_int16_complex_t),
            "::",
            stringify!(imag)
        )
    );
}
#[doc = " @defgroup config Config\n @ingroup service\n\n @brief Module to configure sensor and processing\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_config {
    _unused: [u8; 0],
}
pub type acc_config_t = acc_config;
extern "C" {
    #[doc = " @brief Create a configuration\n\n A configuration is created and populated with default values.\n\n @return A configuration instance"]
    pub fn acc_config_create() -> *mut acc_config_t;
}
extern "C" {
    #[doc = " @brief Destroy a configuration freeing any resources allocated\n\n Destroy a configuration that is no longer needed.\n\n @param[in] config The configuration to destroy, can be NULL"]
    pub fn acc_config_destroy(config: *mut acc_config_t);
}
extern "C" {
    #[doc = " @brief Print a configuration to the log\n\n @param[in] config The configuration to log"]
    pub fn acc_config_log(config: *const acc_config_t);
}
extern "C" {
    #[doc = " @brief Set the starting point of the sweep\n\n This sets the starting point of the sweep. The corresponding start\n in millimeter is approximately start_point * 2.5 mm. For the exact\n distance in meter, use the @ref acc_processing_points_to_meter function.\n\n @param[in] config The configuration\n @param[in] start_point The starting point of the sweep"]
    pub fn acc_config_start_point_set(config: *mut acc_config_t, start_point: i32);
}
extern "C" {
    #[doc = " @brief Get the starting point of the sweep\n\n @see acc_config_start_point_set\n\n @param[in] config The configuration\n @return The starting point of the sweep"]
    pub fn acc_config_start_point_get(config: *const acc_config_t) -> i32;
}
extern "C" {
    #[doc = " @brief Set the number of data points to measure\n\n This sets the number of data points to measure in a sweep.\n\n @param[in] config The configuration\n @param[in] num_points Number of data points to measure"]
    pub fn acc_config_num_points_set(config: *mut acc_config_t, num_points: u16);
}
extern "C" {
    #[doc = " @brief Get the number of data points to measure\n\n @see acc_config_num_points_set\n\n @param[in] config The configuration\n @return Number of data points to measure"]
    pub fn acc_config_num_points_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set the step length in a sweep\n\n This sets the number of steps to have between each data point.\n\n Sampling produces complex (IQ) data points with configurable distance spacing,\n starting from ~2.5mm.\n\n @param[in] config The configuration\n @param[in] step_length The step length"]
    pub fn acc_config_step_length_set(config: *mut acc_config_t, step_length: u16);
}
extern "C" {
    #[doc = " @brief Get the step length in a sweep\n\n @see acc_config_step_length_set\n\n @param[in] config The configuration\n @return The step length"]
    pub fn acc_config_step_length_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set a profile\n\n Each profile consists of a number of settings for the sensor that configures\n the RX and TX paths. Lower profiles have higher depth resolution while\n higher profiles have higher SNR.\n\n @param[in] config The config to set a profile for\n @param[in] profile The profile to set"]
    pub fn acc_config_profile_set(config: *mut acc_config_t, profile: acc_config_profile_t);
}
extern "C" {
    #[doc = " @brief Get the currently used profile\n\n See @ref acc_config_profile_set\n\n @param[in] config The config to get a profile for\n @return The profile currently used"]
    pub fn acc_config_profile_get(config: *const acc_config_t) -> acc_config_profile_t;
}
extern "C" {
    #[doc = " @brief Set the hardware accelerated average samples (HWAAS)\n\n Each data point can be sampled several times and the sensor hardware then\n produces an average value of those samples. The time needed to measure a sweep is roughly proportional\n to the number of averaged samples. Hence, if there is a need to obtain a higher update rate, HWAAS\n could be decreased but this leads to lower SNR.\n\n HWAAS must be between 1 and 511 inclusive\n\n @param[in] config The config to set HWAAS for\n @param[in] hwaas Hardware accelerated average samples"]
    pub fn acc_config_hwaas_set(config: *mut acc_config_t, hwaas: u16);
}
extern "C" {
    #[doc = " @brief Get the hardware accelerated average samples (HWAAS)\n\n @see acc_config_hwaas_set\n\n @param[in] config The config to get HWAAS from\n @return Hardware accelerated average samples"]
    pub fn acc_config_hwaas_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set receiver gain setting\n\n Must be a value between 0 and 23 inclusive where 23 is the highest gain and 0 the lowest.\n\n Lower gain gives higher SNR. However, too low gain may result in quantization, lowering SNR.\n Too high gain may result in saturation, corrupting the data.\n\n @param[in] config The configuration\n @param[in] gain Receiver gain setting"]
    pub fn acc_config_receiver_gain_set(config: *mut acc_config_t, gain: u8);
}
extern "C" {
    #[doc = " @brief Get receiver gain setting\n\n See @ref acc_config_receiver_gain_set\n\n @param[in] config The configuration\n @return Receiver gain setting"]
    pub fn acc_config_receiver_gain_get(config: *const acc_config_t) -> u8;
}
extern "C" {
    #[doc = " @brief Set sweeps per frame\n\n Sets the number of sweeps that will be captured in each frame (measurement).\n Can be set to 0 if e.g. only temperature measurement is wanted.\n\n @param[in] config The configuration\n @param[in] sweeps Sweeps per frame"]
    pub fn acc_config_sweeps_per_frame_set(config: *mut acc_config_t, sweeps: u16);
}
extern "C" {
    #[doc = " @brief Get the number of sweeps per frame\n\n See @ref acc_config_sweeps_per_frame_set\n\n @param[in] config The configuration\n @return Sweeps per frame"]
    pub fn acc_config_sweeps_per_frame_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set the sweep rate\n\n Sets the sweep rate for sweeps in a frame (measurement).\n\n @param[in] config The configuration\n @param[in] sweep_rate Sweep rate in Hz. Must be >= 0, 0 is interpreted as max sweep rate"]
    pub fn acc_config_sweep_rate_set(config: *mut acc_config_t, sweep_rate: f32);
}
extern "C" {
    #[doc = " @brief Get the sweep rate\n\n See @ref acc_config_sweep_rate_set\n\n @param[in] config The configuration\n @return Sweep rate in Hz"]
    pub fn acc_config_sweep_rate_get(config: *const acc_config_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set continuous sweep mode\n\n In continuous sweep mode the timing will be identical over all sweeps, not\n just the sweeps in a frame.\n\n Constraints:\n - Frame rate must be set to unlimited (0.0)\n - Sweep rate must be set (> 0)\n - Inter frame idle state must be set equal to inter sweep idle state\n\n @param[in] config The configuration\n @param[in] enabled true if continuous sweep mode should be enabled, false otherwise"]
    pub fn acc_config_continuous_sweep_mode_set(config: *mut acc_config_t, enabled: bool);
}
extern "C" {
    #[doc = " @brief Get continuous sweep mode\n\n See @ref acc_config_continuous_sweep_mode_set\n\n @param[in] config The configuration\n @return true if continuous sweep mode is enabled, false otherwise"]
    pub fn acc_config_continuous_sweep_mode_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set the frame rate\n\n Sets the frame rate.\n\n Setting the frame rate to unlimited (0) means that the rate is not limited by the\n sensor but the rate that the host acknowledge and reads out the measurement data.\n\n @param[in] config The configuration\n @param[in] frame_rate Frame rate in Hz. Must be >= 0, 0 is interpreted as unlimited"]
    pub fn acc_config_frame_rate_set(config: *mut acc_config_t, frame_rate: f32);
}
extern "C" {
    #[doc = " @brief Get the frame rate\n\n See @ref acc_config_frame_rate_set\n\n @param[in] config The configuration\n @return Frame rate"]
    pub fn acc_config_frame_rate_get(config: *const acc_config_t) -> f32;
}
extern "C" {
    #[doc = " @brief Enable or disable the transmitter\n\n If set to true, TX is enabled. This will enable the radio transmitter.\n By turning the transmitter off the RX noise floor can be measured.\n\n @param[in] config The configuration\n @param[in] enable true to enable the transmitter, false to disable it"]
    pub fn acc_config_enable_tx_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get transmitter enable configuration\n\n See @ref acc_config_enable_tx_set\n\n @param[in] config The configuration\n @return true if the transmitter is enabled, false if it is disabled"]
    pub fn acc_config_enable_tx_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set inter frame idle state\n\n The 'inter-frame idle state' is the state the sensor idles in between each frame.\n\n See also @ref acc_config_idle_state_t.\n\n The inter frame idle state of the frame must be deeper or the same as the inter sweep idle state.\n\n @param[in] config The configuration\n @param[in] idle_state The idle state to use between frames"]
    pub fn acc_config_inter_frame_idle_state_set(
        config: *mut acc_config_t,
        idle_state: acc_config_idle_state_t,
    );
}
extern "C" {
    #[doc = " @brief Get inter frame idle state\n\n See @ref acc_config_inter_frame_idle_state_set\n\n @param[in] config The configuration\n @return The idle state to use between frames"]
    pub fn acc_config_inter_frame_idle_state_get(
        config: *const acc_config_t,
    ) -> acc_config_idle_state_t;
}
extern "C" {
    #[doc = " @brief Set inter sweep idle state\n\n The 'inter-sweep idle state' is the state the sensor idles in between each sweep in a frame.\n\n See also @ref acc_config_idle_state_t.\n\n @param[in] config The configuration\n @param[in] idle_state The idle state to use between sweeps within a frame"]
    pub fn acc_config_inter_sweep_idle_state_set(
        config: *mut acc_config_t,
        idle_state: acc_config_idle_state_t,
    );
}
extern "C" {
    #[doc = " @brief Get inter sweep idle state\n\n See @ref acc_config_inter_sweep_idle_state_set\n\n @param[in] config The configuration\n @return The idle state to use between sweeps within a frame"]
    pub fn acc_config_inter_sweep_idle_state_get(
        config: *const acc_config_t,
    ) -> acc_config_idle_state_t;
}
extern "C" {
    #[doc = " @brief Set Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @param[in] prf The Pulse Repetition Frequency to use"]
    pub fn acc_config_prf_set(config: *mut acc_config_t, prf: acc_config_prf_t);
}
extern "C" {
    #[doc = " @brief Get Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @return Pulse Repetition Frequency"]
    pub fn acc_config_prf_get(config: *const acc_config_t) -> acc_config_prf_t;
}
extern "C" {
    #[doc = " @brief Enable or disable phase enhancement\n\n If enabled, the data phase will be enhanced such that coherent distance filtering can be applied.\n Given a single reflection from an object, the phase will appear as \"flat\" around the amplitude peak.\n\n Enabling the phase enhancement increases the processing execution time.\n\n @param[in] config The configuration\n @param[in] enable true if phase enhancement should be enabled, false otherwise"]
    pub fn acc_config_phase_enhancement_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the phase enhancement configuration\n\n See @ref acc_config_phase_enhancement_set\n\n @param[in] config The configuration\n @return true if phase enhancement is enabled, false otherwise"]
    pub fn acc_config_phase_enhancement_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Enable or disable loopback\n\n Constraints:\n - Loopback can't be enabled together with profile 2.\n\n @param[in] config The configuration\n @param[in] enable true if loopback should be enabled, false otherwise"]
    pub fn acc_config_enable_loopback_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the enable loopback configuration\n\n See @ref acc_config_enable_loopback_set\n\n @param[in] config The configuration\n @return true if loopback is enabled, false otherwise"]
    pub fn acc_config_enable_loopback_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Enable or disable double buffering\n\n If enabled, the sensor buffer will be split in two halves reducing the\n maximum number of samples. A frame can be read using @ref acc_sensor_read while\n sampling is done into the other buffer. Switching of buffers is done automatically\n by @ref acc_sensor_measure.\n\n When using double buffering, measurements coinciding with SPI activity may have distorted phase.\n To mitigate this issue, applying a median filter is recommended.\n\n @param[in] config The configuration\n @param[in] enable true if double buffering should be enabled, false otherwise"]
    pub fn acc_config_double_buffering_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the double buffering configuration\n\n See @ref acc_config_double_buffering_set\n\n @param[in] config The configuration\n @return true if double buffering is enabled, false otherwise"]
    pub fn acc_config_double_buffering_get(config: *const acc_config_t) -> bool;
}
pub type wchar_t = cty::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = cty::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: cty::c_int,
    pub rem: cty::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: cty::c_longlong,
    pub rem: cty::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const cty::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char)
        -> cty::c_ulonglong;
}
extern "C" {
    pub fn strtol(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: cty::c_long) -> *mut cty::c_char;
}
extern "C" {
    pub fn a64l(__s: *const cty::c_char) -> cty::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = cty::c_ulong;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [cty::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::core::mem::MaybeUninit<__sigset_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> cty::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: cty::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: cty::c_uint,
    pub __high: cty::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_slist> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: cty::c_int,
    pub __count: cty::c_uint,
    pub __owner: cty::c_int,
    pub __nusers: cty::c_uint,
    pub __kind: cty::c_int,
    pub __spins: cty::c_short,
    pub __elision: cty::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: cty::c_uint,
    pub __writers: cty::c_uint,
    pub __wrphase_futex: cty::c_uint,
    pub __writers_futex: cty::c_uint,
    pub __pad3: cty::c_uint,
    pub __pad4: cty::c_uint,
    pub __cur_writer: cty::c_int,
    pub __shared: cty::c_int,
    pub __rwelision: cty::c_schar,
    pub __pad1: [cty::c_uchar; 7usize],
    pub __pad2: cty::c_ulong,
    pub __flags: cty::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [cty::c_uint; 2usize],
    pub __g_size: [cty::c_uint; 2usize],
    pub __g1_orig_size: cty::c_uint,
    pub __wrefs: cty::c_uint,
    pub __g_signals: [cty::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = cty::c_uint;
pub type __thrd_t = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: cty::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::core::mem::MaybeUninit<__once_flag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::core::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = cty::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [cty::c_char; 4usize],
    pub __align: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [cty::c_char; 4usize],
    pub __align: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = cty::c_uint;
pub type pthread_once_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [cty::c_char; 56usize],
    pub __align: cty::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [cty::c_char; 40usize],
    pub __align: cty::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [cty::c_char; 48usize],
    pub __align: cty::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [cty::c_char; 56usize],
    pub __align: cty::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [cty::c_char; 8usize],
    pub __align: cty::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [cty::c_char; 32usize],
    pub __align: cty::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrier_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [cty::c_char; 4usize],
    pub __align: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrierattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> cty::c_long;
}
extern "C" {
    pub fn srandom(__seed: cty::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: cty::c_uint,
        __statebuf: *mut cty::c_char,
        __statelen: usize,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut cty::c_char) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: cty::c_int,
    pub rand_deg: cty::c_int,
    pub rand_sep: cty::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::core::mem::MaybeUninit<random_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> cty::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: cty::c_uint, __buf: *mut random_data) -> cty::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: cty::c_uint,
        __statebuf: *mut cty::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> cty::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut cty::c_char, __buf: *mut random_data) -> cty::c_int;
}
extern "C" {
    pub fn rand() -> cty::c_int;
}
extern "C" {
    pub fn srand(__seed: cty::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut cty::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> cty::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn mrand48() -> cty::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn srand48(__seedval: cty::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut cty::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [cty::c_ushort; 3usize],
    pub __old_x: [cty::c_ushort; 3usize],
    pub __c: cty::c_ushort,
    pub __init: cty::c_ushort,
    pub __a: cty::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::core::mem::MaybeUninit<drand48_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> cty::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut cty::c_long,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut cty::c_long,
    ) -> cty::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: cty::c_long, __buffer: *mut drand48_data) -> cty::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut cty::c_ushort, __buffer: *mut drand48_data) -> cty::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut cty::c_ushort, __buffer: *mut drand48_data) -> cty::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut cty::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: cty::c_ulong, __size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut cty::c_void, __size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut cty::c_void);
}
extern "C" {
    pub fn reallocarray(__ptr: *mut cty::c_void, __nmemb: usize, __size: usize)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn alloca(__size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut cty::c_void,
        __alignment: usize,
        __size: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: cty::c_ulong, __size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: cty::c_int, __arg: *mut cty::c_void),
        >,
        __arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn exit(__status: cty::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: cty::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: cty::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const cty::c_char,
        __value: *const cty::c_char,
        __replace: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn clearenv() -> cty::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut cty::c_char, __suffixlen: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn system(__command: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn realpath(__name: *const cty::c_char, __resolved: *mut cty::c_char) -> *mut cty::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const cty::c_void,
        __base: *const cty::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut cty::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn labs(__x: cty::c_long) -> cty::c_long;
}
extern "C" {
    pub fn llabs(__x: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    pub fn div(__numer: cty::c_int, __denom: cty::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: cty::c_long, __denom: cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: cty::c_longlong, __denom: cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: cty::c_int, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: cty::c_ulonglong,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: cty::c_ulonglong,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: cty::c_ulonglong,
        __ndigit: cty::c_int,
        __buf: *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: cty::c_ulonglong,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: cty::c_ulonglong,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mblen(__s: *const cty::c_char, __n: usize) -> cty::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const cty::c_char, __n: usize) -> cty::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut cty::c_char, __wchar: wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const cty::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut cty::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut cty::c_char,
        __tokens: *const *mut cty::c_char,
        __valuep: *mut *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: cty::c_int) -> cty::c_int;
}
#[doc = " @brief Definition of a memory allocation function\n\n Allocated memory should be suitably aligned for any built-in type. Returning NULL is seen as failure."]
pub type acc_hal_mem_alloc_function_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut cty::c_void>;
#[doc = " @brief Definition of a memory free function\n\n Free memory which is previously allocated."]
pub type acc_hal_mem_free_function_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
#[doc = " @brief Definition of a sensor transfer function\n\n This function shall transfer data to and from the sensor over spi. It's beneficial from a performance perspective\n to use dma if available.\n The buffer is naturally aligned to a maximum of 4 bytes.\n"]
pub type acc_hal_sensor_transfer8_function_t = ::core::option::Option<
    unsafe extern "C" fn(sensor_id: acc_sensor_id_t, buffer: *mut u8, buffer_size: usize),
>;
#[doc = " @brief Definition of an optimized 16-bit sensor transfer function\n\n This function shall transfer data to and from the sensor over spi with 16 bits data size.\n It's beneficial from a performance perspective to use dma if available.\n The buffer is naturally aligned to a minimum of 4 bytes.\n\n If defined it will supersede the normal 8-bit function @ref acc_hal_sensor_transfer8_function_t\n"]
pub type acc_hal_sensor_transfer16_function_t = ::core::option::Option<
    unsafe extern "C" fn(sensor_id: acc_sensor_id_t, buffer: *mut u16, buffer_length: usize),
>;
#[doc = " @brief This struct contains function pointers that are optional to support different optimizations\n\n Optional\n\n This struct contains function pointers to support different optimizations.\n These optimizations can be utilized for some integrations.\n If they are defined, they will override the corresponding non-optimized function.\n\n For example, if the transfer16 function is implemented, it will be used instead of the transfer function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_hal_optimization_t {
    pub transfer16: acc_hal_sensor_transfer16_function_t,
}
#[test]
fn bindgen_test_layout_acc_hal_optimization_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_hal_optimization_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_hal_optimization_t>(),
        8usize,
        concat!("Size of: ", stringify!(acc_hal_optimization_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_hal_optimization_t>(),
        8usize,
        concat!("Alignment of ", stringify!(acc_hal_optimization_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transfer16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_hal_optimization_t),
            "::",
            stringify!(transfer16)
        )
    );
}
#[doc = " @brief Definition of a log function"]
pub type acc_hal_log_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        level: acc_log_level_t,
        module: *const cty::c_char,
        format: *const cty::c_char,
        ...
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_hal_a121_t {
    pub max_spi_transfer_size: u16,
    pub mem_alloc: acc_hal_mem_alloc_function_t,
    pub mem_free: acc_hal_mem_free_function_t,
    pub transfer: acc_hal_sensor_transfer8_function_t,
    pub log: acc_hal_log_function_t,
    pub optimization: acc_hal_optimization_t,
}
#[test]
fn bindgen_test_layout_acc_hal_a121_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_hal_a121_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_hal_a121_t>(),
        48usize,
        concat!("Size of: ", stringify!(acc_hal_a121_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_hal_a121_t>(),
        8usize,
        concat!("Alignment of ", stringify!(acc_hal_a121_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_spi_transfer_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_hal_a121_t),
            "::",
            stringify!(max_spi_transfer_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_alloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_hal_a121_t),
            "::",
            stringify!(mem_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_hal_a121_t),
            "::",
            stringify!(mem_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transfer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_hal_a121_t),
            "::",
            stringify!(transfer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_hal_a121_t),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).optimization) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_hal_a121_t),
            "::",
            stringify!(optimization)
        )
    );
}
#[doc = " The test is ongoing, the application should call test function again"]
pub const acc_rss_test_state_t_ACC_RSS_TEST_STATE_ONGOING: acc_rss_test_state_t = 0;
#[doc = " The application should toggle enable pin and then call test function again"]
pub const acc_rss_test_state_t_ACC_RSS_TEST_STATE_TOGGLE_ENABLE_PIN: acc_rss_test_state_t = 1;
#[doc = " The application should wait for interrupt and then call test function again"]
pub const acc_rss_test_state_t_ACC_RSS_TEST_STATE_WAIT_FOR_INTERRUPT: acc_rss_test_state_t = 2;
#[doc = " The test is complete"]
pub const acc_rss_test_state_t_ACC_RSS_TEST_STATE_COMPLETE: acc_rss_test_state_t = 3;
#[doc = " @brief Return code for rss tests\n"]
pub type acc_rss_test_state_t = cty::c_uint;
#[doc = " The test status is OK"]
pub const acc_rss_test_integration_status_t_ACC_RSS_TEST_INTEGRATION_STATUS_OK:
    acc_rss_test_integration_status_t = 0;
#[doc = " The test has timed out"]
pub const acc_rss_test_integration_status_t_ACC_RSS_TEST_INTEGRATION_STATUS_TIMEOUT:
    acc_rss_test_integration_status_t = 1;
#[doc = " @brief Integration status for rss tests\n"]
pub type acc_rss_test_integration_status_t = cty::c_uint;
#[doc = " Test SPI basic read functionality."]
pub const acc_rss_assembly_test_test_id_t_ACC_RSS_ASSEMBLY_TEST_ID_BASIC_READ:
    acc_rss_assembly_test_test_id_t = 0;
#[doc = " Test SPI communication."]
pub const acc_rss_assembly_test_test_id_t_ACC_RSS_ASSEMBLY_TEST_ID_COMMUNICATION:
    acc_rss_assembly_test_test_id_t = 1;
#[doc = " Test enable pin."]
pub const acc_rss_assembly_test_test_id_t_ACC_RSS_ASSEMBLY_TEST_ID_ENABLE_PIN:
    acc_rss_assembly_test_test_id_t = 2;
#[doc = " Test interrupt pin."]
pub const acc_rss_assembly_test_test_id_t_ACC_RSS_ASSEMBLY_TEST_ID_INTERRUPT:
    acc_rss_assembly_test_test_id_t = 3;
#[doc = " Test clock and supply stability."]
pub const acc_rss_assembly_test_test_id_t_ACC_RSS_ASSEMBLY_TEST_ID_CLOCK_AND_SUPPLY:
    acc_rss_assembly_test_test_id_t = 4;
#[doc = " Test sensor calibration."]
pub const acc_rss_assembly_test_test_id_t_ACC_RSS_ASSEMBLY_TEST_ID_SENSOR_CALIBRATION:
    acc_rss_assembly_test_test_id_t = 5;
#[doc = " @brief Test identity enum for acc_rss_assembly_test\n"]
pub type acc_rss_assembly_test_test_id_t = cty::c_uint;
#[doc = " @brief The result struct of acc_rss_assembly_test\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_rss_assembly_test_result_t {
    pub test_name: *const cty::c_char,
    pub test_result: bool,
}
#[test]
fn bindgen_test_layout_acc_rss_assembly_test_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_rss_assembly_test_result_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_rss_assembly_test_result_t>(),
        16usize,
        concat!("Size of: ", stringify!(acc_rss_assembly_test_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_rss_assembly_test_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(acc_rss_assembly_test_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_rss_assembly_test_result_t),
            "::",
            stringify!(test_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_result) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_rss_assembly_test_result_t),
            "::",
            stringify!(test_result)
        )
    );
}
#[doc = " @brief The acc_rss_assembly_test instance\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_rss_assembly_test {
    _unused: [u8; 0],
}
pub type acc_rss_assembly_test_t = acc_rss_assembly_test;
extern "C" {
    #[doc = " @brief Register an integration\n\n @param[in] hal A reference to the hal to register\n @return True if a valid integration is registered, false otherwise"]
    pub fn acc_rss_hal_register(hal: *const acc_hal_a121_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get the buffer size needed for the specified config\n\n This buffer size can be used to allocate a memory buffer in the\n application, which is needed for several functions in the RSS library.\n\n @param[in] config The config to get the buffer size for\n @param[out] buffer_size The buffer size\n @return True if successful, false otherwise"]
    pub fn acc_rss_get_buffer_size(config: *const acc_config_t, buffer_size: *mut u32) -> bool;
}
extern "C" {
    #[doc = " @brief Set the log level that determines when the integration HAL logger function is called\n\n Shall be called when there is a hal registered in RSS as it has no effect otherwise.\n\n @param[in] level The severity level for log output."]
    pub fn acc_rss_set_log_level(level: acc_log_level_t);
}
extern "C" {
    #[doc = " @brief Create a sensor assembly test instance\n\n The assembly test instance is used to keep track of internal state and\n results of the assembly test.\n\n The provided buffer start address should be 32-bit aligned.\n The size of the provided buffer must be at least ACC_RSS_ASSEMBLY_TEST_MIN_BUFFER_SIZE bytes.\n The size of the provided buffer should be a multiple of 8 bytes.\n The test will not behave differently if a larger buffer is provided.\n\n All assembly tests are enabled by default after creation.\n\n @param[in] sensor_id The sensor id to be used to communicate with\n @param[in] buffer A buffer used for assembly test\n @param[in] buffer_size The size of the buffer\n\n @return Assembly test instance, NULL if the creation of the instance failed"]
    pub fn acc_rss_assembly_test_create(
        sensor_id: acc_sensor_id_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> *mut acc_rss_assembly_test_t;
}
extern "C" {
    #[doc = " @brief Destroy a sensor assembly test instance freeing any resources allocated.\n\n @param[in] assembly_test The assembly_test instance to destroy, can be NULL"]
    pub fn acc_rss_assembly_test_destroy(assembly_test: *mut acc_rss_assembly_test_t);
}
extern "C" {
    #[doc = " @brief Enable disagnostic logs for the assembly test,"]
    pub fn acc_rss_assembly_test_enable_diagnostic_logs();
}
extern "C" {
    #[doc = " @brief Enable all assembly tests\n\n @param[in] assembly_test The assembly_test instance"]
    pub fn acc_rss_assembly_test_enable_all_tests(assembly_test: *mut acc_rss_assembly_test_t);
}
extern "C" {
    #[doc = " @brief Disable all assembly tests\n\n @param[in] assembly_test The assembly_test instance"]
    pub fn acc_rss_assembly_test_disable_all_tests(assembly_test: *mut acc_rss_assembly_test_t);
}
extern "C" {
    #[doc = " @brief Enable a test in assembly test\n\n @param[in] assembly_test The assembly_test instance\n @param[in] test_id The id of the test to be enabled"]
    pub fn acc_rss_assembly_test_enable(
        assembly_test: *mut acc_rss_assembly_test_t,
        test_id: acc_rss_assembly_test_test_id_t,
    );
}
extern "C" {
    #[doc = " @brief Disable a test in assembly test\n\n @param[in] assembly_test The assembly_test instance\n @param[in] test_id The id of the test to be enabled"]
    pub fn acc_rss_assembly_test_disable(
        assembly_test: *mut acc_rss_assembly_test_t,
        test_id: acc_rss_assembly_test_test_id_t,
    );
}
extern "C" {
    #[doc = " @brief Execute the assembly test\n\n The sensor must be powered on and enabled before this function is called.\n\n The function should be called repeatedly until it returns ACC_RSS_TEST_STATE_COMPLETE.\n If the function returns ACC_RSS_TEST_STATE_TOGGLE_ENABLE_PIN the caller should toggle the\n enable pin to reset the sensor and then call @ref acc_rss_assembly_test_execute() again.\n If the function returns ACC_RSS_TEST_STATE_WAIT_FOR_INTERRUPT the caller have to wait for\n the interrupt pin before calling @ref acc_rss_assembly_test_execute() again.\n\n After assembly test has been run the sensor enable pin should be toggled to reset the sensor.\n\n @param[in, out] assembly_test The sensor assembly test instance\n @param[in] integration_status Report back to assembly test if 'wait for interrupt' timed out\n @return ACC_RSS_TEST_STATE_ONGOING if caller should call this function again.\n         ACC_RSS_TEST_STATE_TOGGLE_ENABLE_PIN if caller should toggle the enable pin.\n         ACC_RSS_TEST_STATE_WAIT_FOR_INTERRUPT if caller should wait for interrupt pin.\n\t       or ACC_RSS_TEST_STATE_COMPLETE if the assembly test is complete."]
    pub fn acc_rss_assembly_test_execute(
        assembly_test: *mut acc_rss_assembly_test_t,
        integration_status: acc_rss_test_integration_status_t,
    ) -> acc_rss_test_state_t;
}
extern "C" {
    #[doc = " @brief A function to get the results from the sensor assembly test\n\n @param[in] assembly_test The sensor assembly test instance\n @param[out] nbr_of_test_results The number of test results returned\n @return The assembly test result array"]
    pub fn acc_rss_assembly_test_get_results(
        assembly_test: *const acc_rss_assembly_test_t,
        nbr_of_test_results: *mut u16,
    ) -> *const acc_rss_assembly_test_result_t;
}
