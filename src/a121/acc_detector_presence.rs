/* automatically generated by rust-bindgen 0.69.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ACC_CAL_RESULT_DATA_SIZE: u32 = 192;
pub const ACC_MAX_NUM_SUBSWEEPS: u32 = 4;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const PRIsensor_id: &[u8; 2] = b"u\0";
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __suseconds64_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " The result from a completed calibration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_cal_result_t {
    pub data: [u8; 192usize],
}
#[test]
fn bindgen_test_layout_acc_cal_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_cal_result_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_cal_result_t>(),
        192usize,
        concat!("Size of: ", stringify!(acc_cal_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_cal_result_t>(),
        1usize,
        concat!("Alignment of ", stringify!(acc_cal_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_cal_result_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Information about calibration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_cal_info_t {
    pub temperature: i16,
}
#[test]
fn bindgen_test_layout_acc_cal_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_cal_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_cal_info_t>(),
        2usize,
        concat!("Size of: ", stringify!(acc_cal_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_cal_info_t>(),
        2usize,
        concat!("Alignment of ", stringify!(acc_cal_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_cal_info_t),
            "::",
            stringify!(temperature)
        )
    );
}
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_1: acc_config_profile_t = 1;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_2: acc_config_profile_t = 2;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_3: acc_config_profile_t = 3;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_4: acc_config_profile_t = 4;
#[doc = " The profile with the lowest depth resolution and highest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_5: acc_config_profile_t = 5;
#[doc = " @brief Profile\n\n Each profile consists of a number of settings for the sensor that configures the RX and TX paths.\n Lower profiles have higher depth resolution while higher profiles have higher radar loop gain."]
pub type acc_config_profile_t = cty::c_uint;
#[doc = " The deepest state where as much of the sensor hardware is shut down."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_DEEP_SLEEP: acc_config_idle_state_t = 0;
#[doc = " The deepest state where as much of the sensor hardware is shut down."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_SLEEP: acc_config_idle_state_t = 1;
#[doc = " The shallowest state where most of the sensor hardware is kept on."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_READY: acc_config_idle_state_t = 2;
#[doc = " @brief Idle state\n\n Idle state 'DEEP_SLEEP' is the deepest state where as much of the sensor hardware as\n possible is shut down and idle state 'READY' is the shallowest state where most of the sensor\n hardware is kept on.\n\n DEEP_SLEEP is the slowest to transition from while READY is the fastest.\n"]
pub type acc_config_idle_state_t = cty::c_uint;
#[doc = " 19.5 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_19_5_MHZ: acc_config_prf_t = 0;
#[doc = " 15.6 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_15_6_MHZ: acc_config_prf_t = 1;
#[doc = " 13.0 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_13_0_MHZ: acc_config_prf_t = 2;
#[doc = " 8.7 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_8_7_MHZ: acc_config_prf_t = 3;
#[doc = " 6.5 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_6_5_MHZ: acc_config_prf_t = 4;
#[doc = " 5.2 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_5_2_MHZ: acc_config_prf_t = 5;
#[doc = " @brief Pulse Repetition Frequency\n\n Pulse Repetition Frequency, PRF, is the frequency at\n which pulses are sent out from the radar system. The\n measurement time is approximately proportional to the\n PRF. The higher the PRF, the shorter the measurement time.\n\n This parameter sets the Maximum Measurable Distance, MMD,\n that can be achieved. MMD is the maximum value for the end point,\n i.e.,the start point + (number of points * step length).\n For example, an MMD of 7.0 m means that the range cannot\n be set further out than 7.0 m.\n\n It also sets the Maximum Unambiguous Range, MUR, that can be achieved.\n MUR is the maximum distance at which an object can be located to guarantee\n that its reflection corresponds to the most recent transmitted pulse.\n Objects farther away than the MUR may fold into the measured range.\n For example, with a MUR of 11.5 m, an object at 13.5 m could become\n visible at 2 m.\n\n | PRF Setting              |      PRF |    MMD |    MUR |\n |-------------------------:|---------:|-------:|-------:|\n | ACC_CONFIG_PRF_19_5_MHZ* | 19.5 MHz |  3.1 m |  7.7 m |\n | ACC_CONFIG_PRF_15_6_MHZ  | 15.6 MHz |  5.1 m |  9.6 m |\n | ACC_CONFIG_PRF_13_0_MHZ  | 13.0 MHz |  7.0 m | 11.5 m |\n | ACC_CONFIG_PRF_8_7_MHZ   |  8.7 MHz | 12.7 m | 17.3 m |\n | ACC_CONFIG_PRF_6_5_MHZ   |  6.5 MHz | 18.5 m | 23.1 m |\n | ACC_CONFIG_PRF_5_2_MHZ   |  5.2 MHz | 24.3 m | 28.8 m |\n\n *19.5MHz is only available for profile 1."]
pub type acc_config_prf_t = cty::c_uint;
pub type __gwchar_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> uintmax_t;
}
#[doc = " @brief Type representing a sensor ID"]
pub type acc_sensor_id_t = u32;
#[doc = " ERROR log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_ERROR: acc_log_level_t = 0;
#[doc = " WARNING log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_WARNING: acc_log_level_t = 1;
#[doc = " INFO log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_INFO: acc_log_level_t = 2;
#[doc = " VERBOSE log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_VERBOSE: acc_log_level_t = 3;
#[doc = " DEBUG log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_DEBUG: acc_log_level_t = 4;
#[doc = " @brief This enum represents the different log levels for RSS"]
pub type acc_log_level_t = cty::c_uint;
#[doc = " @brief Data type for interger-based representation of complex numbers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_int16_complex_t {
    pub real: i16,
    pub imag: i16,
}
#[test]
fn bindgen_test_layout_acc_int16_complex_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_int16_complex_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_int16_complex_t>(),
        4usize,
        concat!("Size of: ", stringify!(acc_int16_complex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_int16_complex_t>(),
        2usize,
        concat!("Alignment of ", stringify!(acc_int16_complex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_int16_complex_t),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_int16_complex_t),
            "::",
            stringify!(imag)
        )
    );
}
#[doc = " @defgroup config Config\n @ingroup service\n\n @brief Module to configure sensor and processing\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_config {
    _unused: [u8; 0],
}
pub type acc_config_t = acc_config;
extern "C" {
    #[doc = " @brief Create a configuration\n\n A configuration is created and populated with default values.\n\n @return A configuration instance"]
    pub fn acc_config_create() -> *mut acc_config_t;
}
extern "C" {
    #[doc = " @brief Destroy a configuration freeing any resources allocated\n\n Destroy a configuration that is no longer needed.\n\n @param[in] config The configuration to destroy, can be NULL"]
    pub fn acc_config_destroy(config: *mut acc_config_t);
}
extern "C" {
    #[doc = " @brief Print a configuration to the log\n\n @param[in] config The configuration to log"]
    pub fn acc_config_log(config: *const acc_config_t);
}
extern "C" {
    #[doc = " @brief Set the starting point of the sweep\n\n This sets the starting point of the sweep. The corresponding start\n in millimeter is approximately start_point * 2.5 mm. For the exact\n distance in meter, use the @ref acc_processing_points_to_meter function.\n\n @param[in] config The configuration\n @param[in] start_point The starting point of the sweep"]
    pub fn acc_config_start_point_set(config: *mut acc_config_t, start_point: i32);
}
extern "C" {
    #[doc = " @brief Get the starting point of the sweep\n\n @see acc_config_start_point_set\n\n @param[in] config The configuration\n @return The starting point of the sweep"]
    pub fn acc_config_start_point_get(config: *const acc_config_t) -> i32;
}
extern "C" {
    #[doc = " @brief Set the number of data points to measure\n\n This sets the number of data points to measure in a sweep.\n\n @param[in] config The configuration\n @param[in] num_points Number of data points to measure"]
    pub fn acc_config_num_points_set(config: *mut acc_config_t, num_points: u16);
}
extern "C" {
    #[doc = " @brief Get the number of data points to measure\n\n @see acc_config_num_points_set\n\n @param[in] config The configuration\n @return Number of data points to measure"]
    pub fn acc_config_num_points_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set the step length in a sweep\n\n This sets the number of steps to have between each data point.\n\n Sampling produces complex (IQ) data points with configurable distance spacing,\n starting from ~2.5mm.\n\n @param[in] config The configuration\n @param[in] step_length The step length"]
    pub fn acc_config_step_length_set(config: *mut acc_config_t, step_length: u16);
}
extern "C" {
    #[doc = " @brief Get the step length in a sweep\n\n @see acc_config_step_length_set\n\n @param[in] config The configuration\n @return The step length"]
    pub fn acc_config_step_length_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set a profile\n\n Each profile consists of a number of settings for the sensor that configures\n the RX and TX paths. Lower profiles have higher depth resolution while\n higher profiles have higher SNR.\n\n @param[in] config The config to set a profile for\n @param[in] profile The profile to set"]
    pub fn acc_config_profile_set(config: *mut acc_config_t, profile: acc_config_profile_t);
}
extern "C" {
    #[doc = " @brief Get the currently used profile\n\n See @ref acc_config_profile_set\n\n @param[in] config The config to get a profile for\n @return The profile currently used"]
    pub fn acc_config_profile_get(config: *const acc_config_t) -> acc_config_profile_t;
}
extern "C" {
    #[doc = " @brief Set the hardware accelerated average samples (HWAAS)\n\n Each data point can be sampled several times and the sensor hardware then\n produces an average value of those samples. The time needed to measure a sweep is roughly proportional\n to the number of averaged samples. Hence, if there is a need to obtain a higher update rate, HWAAS\n could be decreased but this leads to lower SNR.\n\n HWAAS must be between 1 and 511 inclusive\n\n @param[in] config The config to set HWAAS for\n @param[in] hwaas Hardware accelerated average samples"]
    pub fn acc_config_hwaas_set(config: *mut acc_config_t, hwaas: u16);
}
extern "C" {
    #[doc = " @brief Get the hardware accelerated average samples (HWAAS)\n\n @see acc_config_hwaas_set\n\n @param[in] config The config to get HWAAS from\n @return Hardware accelerated average samples"]
    pub fn acc_config_hwaas_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set receiver gain setting\n\n Must be a value between 0 and 23 inclusive where 23 is the highest gain and 0 the lowest.\n\n Lower gain gives higher SNR. However, too low gain may result in quantization, lowering SNR.\n Too high gain may result in saturation, corrupting the data.\n\n @param[in] config The configuration\n @param[in] gain Receiver gain setting"]
    pub fn acc_config_receiver_gain_set(config: *mut acc_config_t, gain: u8);
}
extern "C" {
    #[doc = " @brief Get receiver gain setting\n\n See @ref acc_config_receiver_gain_set\n\n @param[in] config The configuration\n @return Receiver gain setting"]
    pub fn acc_config_receiver_gain_get(config: *const acc_config_t) -> u8;
}
extern "C" {
    #[doc = " @brief Set sweeps per frame\n\n Sets the number of sweeps that will be captured in each frame (measurement).\n Can be set to 0 if e.g. only temperature measurement is wanted.\n\n @param[in] config The configuration\n @param[in] sweeps Sweeps per frame"]
    pub fn acc_config_sweeps_per_frame_set(config: *mut acc_config_t, sweeps: u16);
}
extern "C" {
    #[doc = " @brief Get the number of sweeps per frame\n\n See @ref acc_config_sweeps_per_frame_set\n\n @param[in] config The configuration\n @return Sweeps per frame"]
    pub fn acc_config_sweeps_per_frame_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set the sweep rate\n\n Sets the sweep rate for sweeps in a frame (measurement).\n\n @param[in] config The configuration\n @param[in] sweep_rate Sweep rate in Hz. Must be >= 0, 0 is interpreted as max sweep rate"]
    pub fn acc_config_sweep_rate_set(config: *mut acc_config_t, sweep_rate: f32);
}
extern "C" {
    #[doc = " @brief Get the sweep rate\n\n See @ref acc_config_sweep_rate_set\n\n @param[in] config The configuration\n @return Sweep rate in Hz"]
    pub fn acc_config_sweep_rate_get(config: *const acc_config_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set continuous sweep mode\n\n In continuous sweep mode the timing will be identical over all sweeps, not\n just the sweeps in a frame.\n\n Constraints:\n - Frame rate must be set to unlimited (0.0)\n - Sweep rate must be set (> 0)\n - Inter frame idle state must be set equal to inter sweep idle state\n\n @param[in] config The configuration\n @param[in] enabled true if continuous sweep mode should be enabled, false otherwise"]
    pub fn acc_config_continuous_sweep_mode_set(config: *mut acc_config_t, enabled: bool);
}
extern "C" {
    #[doc = " @brief Get continuous sweep mode\n\n See @ref acc_config_continuous_sweep_mode_set\n\n @param[in] config The configuration\n @return true if continuous sweep mode is enabled, false otherwise"]
    pub fn acc_config_continuous_sweep_mode_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set the frame rate\n\n Sets the frame rate.\n\n Setting the frame rate to unlimited (0) means that the rate is not limited by the\n sensor but the rate that the host acknowledge and reads out the measurement data.\n\n @param[in] config The configuration\n @param[in] frame_rate Frame rate in Hz. Must be >= 0, 0 is interpreted as unlimited"]
    pub fn acc_config_frame_rate_set(config: *mut acc_config_t, frame_rate: f32);
}
extern "C" {
    #[doc = " @brief Get the frame rate\n\n See @ref acc_config_frame_rate_set\n\n @param[in] config The configuration\n @return Frame rate"]
    pub fn acc_config_frame_rate_get(config: *const acc_config_t) -> f32;
}
extern "C" {
    #[doc = " @brief Enable or disable the transmitter\n\n If set to true, TX is enabled. This will enable the radio transmitter.\n By turning the transmitter off the RX noise floor can be measured.\n\n @param[in] config The configuration\n @param[in] enable true to enable the transmitter, false to disable it"]
    pub fn acc_config_enable_tx_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get transmitter enable configuration\n\n See @ref acc_config_enable_tx_set\n\n @param[in] config The configuration\n @return true if the transmitter is enabled, false if it is disabled"]
    pub fn acc_config_enable_tx_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set inter frame idle state\n\n The 'inter-frame idle state' is the state the sensor idles in between each frame.\n\n See also @ref acc_config_idle_state_t.\n\n The inter frame idle state of the frame must be deeper or the same as the inter sweep idle state.\n\n @param[in] config The configuration\n @param[in] idle_state The idle state to use between frames"]
    pub fn acc_config_inter_frame_idle_state_set(
        config: *mut acc_config_t,
        idle_state: acc_config_idle_state_t,
    );
}
extern "C" {
    #[doc = " @brief Get inter frame idle state\n\n See @ref acc_config_inter_frame_idle_state_set\n\n @param[in] config The configuration\n @return The idle state to use between frames"]
    pub fn acc_config_inter_frame_idle_state_get(
        config: *const acc_config_t,
    ) -> acc_config_idle_state_t;
}
extern "C" {
    #[doc = " @brief Set inter sweep idle state\n\n The 'inter-sweep idle state' is the state the sensor idles in between each sweep in a frame.\n\n See also @ref acc_config_idle_state_t.\n\n @param[in] config The configuration\n @param[in] idle_state The idle state to use between sweeps within a frame"]
    pub fn acc_config_inter_sweep_idle_state_set(
        config: *mut acc_config_t,
        idle_state: acc_config_idle_state_t,
    );
}
extern "C" {
    #[doc = " @brief Get inter sweep idle state\n\n See @ref acc_config_inter_sweep_idle_state_set\n\n @param[in] config The configuration\n @return The idle state to use between sweeps within a frame"]
    pub fn acc_config_inter_sweep_idle_state_get(
        config: *const acc_config_t,
    ) -> acc_config_idle_state_t;
}
extern "C" {
    #[doc = " @brief Set Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @param[in] prf The Pulse Repetition Frequency to use"]
    pub fn acc_config_prf_set(config: *mut acc_config_t, prf: acc_config_prf_t);
}
extern "C" {
    #[doc = " @brief Get Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @return Pulse Repetition Frequency"]
    pub fn acc_config_prf_get(config: *const acc_config_t) -> acc_config_prf_t;
}
extern "C" {
    #[doc = " @brief Enable or disable phase enhancement\n\n If enabled, the data phase will be enhanced such that coherent distance filtering can be applied.\n Given a single reflection from an object, the phase will appear as \"flat\" around the amplitude peak.\n\n Enabling the phase enhancement increases the processing execution time.\n\n @param[in] config The configuration\n @param[in] enable true if phase enhancement should be enabled, false otherwise"]
    pub fn acc_config_phase_enhancement_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the phase enhancement configuration\n\n See @ref acc_config_phase_enhancement_set\n\n @param[in] config The configuration\n @return true if phase enhancement is enabled, false otherwise"]
    pub fn acc_config_phase_enhancement_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Enable or disable loopback\n\n Constraints:\n - Loopback can't be enabled together with profile 2.\n\n @param[in] config The configuration\n @param[in] enable true if loopback should be enabled, false otherwise"]
    pub fn acc_config_enable_loopback_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the enable loopback configuration\n\n See @ref acc_config_enable_loopback_set\n\n @param[in] config The configuration\n @return true if loopback is enabled, false otherwise"]
    pub fn acc_config_enable_loopback_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Enable or disable double buffering\n\n If enabled, the sensor buffer will be split in two halves reducing the\n maximum number of samples. A frame can be read using @ref acc_sensor_read while\n sampling is done into the other buffer. Switching of buffers is done automatically\n by @ref acc_sensor_measure.\n\n When using double buffering, measurements coinciding with SPI activity may have distorted phase.\n To mitigate this issue, applying a median filter is recommended.\n\n @param[in] config The configuration\n @param[in] enable true if double buffering should be enabled, false otherwise"]
    pub fn acc_config_double_buffering_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the double buffering configuration\n\n See @ref acc_config_double_buffering_set\n\n @param[in] config The configuration\n @return true if double buffering is enabled, false otherwise"]
    pub fn acc_config_double_buffering_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set the number of subsweeps to use\n\n @param[in] config The configuration\n @param[in] num_subsweeps The number of subsweeps"]
    pub fn acc_config_num_subsweeps_set(config: *mut acc_config_t, num_subsweeps: u8);
}
extern "C" {
    #[doc = " @brief Get the number of subsweeps to use\n\n @param[in] config The configuration\n @return The number of subsweeps"]
    pub fn acc_config_num_subsweeps_get(config: *const acc_config_t) -> u8;
}
extern "C" {
    #[doc = " @brief Set the starting point of the sweep\n\n See @ref acc_config_start_point_set\n\n @param[in] config The configuration\n @param[in] start_point The starting point of the sweep\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_start_point_set(
        config: *mut acc_config_t,
        start_point: i32,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the starting point of the sweep\n\n See @ref acc_config_start_point_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return The starting point of the sweep"]
    pub fn acc_config_subsweep_start_point_get(config: *const acc_config_t, index: u8) -> i32;
}
extern "C" {
    #[doc = " @brief Set the number of data points to measure\n\n See @ref acc_config_num_points_set\n\n @param[in] config The configuration\n @param[in] num_points Number of data points to measure\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_num_points_set(
        config: *mut acc_config_t,
        num_points: u16,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the number of data points to measure\n\n See @ref acc_config_num_points_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return Number of data points to measure"]
    pub fn acc_config_subsweep_num_points_get(config: *const acc_config_t, index: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Set the step length in a sweep\n\n See @ref acc_config_step_length_set\n\n @param[in] config The configuration\n @param[in] step_length The step length\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_step_length_set(
        config: *mut acc_config_t,
        step_length: u16,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the step length in a sweep\n\n See @ref acc_config_step_length_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return The step length"]
    pub fn acc_config_subsweep_step_length_get(config: *const acc_config_t, index: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Set a profile\n\n See @ref acc_config_profile_set\n\n @param[in] config The config to set a profile for\n @param[in] profile The profile to set\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_profile_set(
        config: *mut acc_config_t,
        profile: acc_config_profile_t,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the currently used profile\n\n See @ref acc_config_profile_get\n\n @param[in] config The config to get a profile for\n @param[in] index The subsweep index\n @return The current profile, 0 if config is invalid"]
    pub fn acc_config_subsweep_profile_get(
        config: *const acc_config_t,
        index: u8,
    ) -> acc_config_profile_t;
}
extern "C" {
    #[doc = " @brief Set the hardware accelerated average samples (HWAAS)\n\n See @ref acc_config_hwaas_set\n\n @param[in] config The config to set hwaas for\n @param[in] hwaas Hardware accelerated average samples\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_hwaas_set(config: *mut acc_config_t, hwaas: u16, index: u8);
}
extern "C" {
    #[doc = " @brief Get the hardware accelerated average samples (HWAAS)\n\n See @ref acc_config_hwaas_get\n\n @param[in] config The config to get hwaas from\n @param[in] index The subsweep index\n @return Hardware accelerated average samples"]
    pub fn acc_config_subsweep_hwaas_get(config: *const acc_config_t, index: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Set receiver gain setting\n\n See @ref acc_config_receiver_gain_set\n\n @param[in] config The configuration\n @param[in] gain Receiver gain setting\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_receiver_gain_set(config: *mut acc_config_t, gain: u8, index: u8);
}
extern "C" {
    #[doc = " @brief Get receiver gain setting\n\n See @ref acc_config_receiver_gain_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return Receiver gain setting"]
    pub fn acc_config_subsweep_receiver_gain_get(config: *const acc_config_t, index: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Enable or disable the transmitter\n\n See @ref acc_config_enable_tx_set\n\n @param[in] config The configuration\n @param[in] enable true to enable the transmitter\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_enable_tx_set(config: *mut acc_config_t, enable: bool, index: u8);
}
extern "C" {
    #[doc = " @brief Get transmitter enable mode\n\n See @ref acc_config_enable_tx_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return true if the transmitter is enabled"]
    pub fn acc_config_subsweep_enable_tx_get(config: *const acc_config_t, index: u8) -> bool;
}
extern "C" {
    #[doc = " @brief Set Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @param[in] prf The Pulse Repetition Frequency to use\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_prf_set(config: *mut acc_config_t, prf: acc_config_prf_t, index: u8);
}
extern "C" {
    #[doc = " @brief Get Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @return Pulse Repetition Frequency\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_prf_get(config: *const acc_config_t, index: u8) -> acc_config_prf_t;
}
extern "C" {
    #[doc = " @brief Set the phase enhancement enabled configuration\n\n See @ref acc_config_phase_enhancement_set\n\n @param[in] config The configuration\n @param[in] enable true if phase enhancement to be enabled, false otherwise\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_phase_enhancement_set(
        config: *mut acc_config_t,
        enable: bool,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the phase enhancement enabled configuration\n\n See @ref acc_config_phase_enhancement_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return true if phase enhancement is enabled, false otherwise"]
    pub fn acc_config_subsweep_phase_enhancement_get(
        config: *const acc_config_t,
        index: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the loopback enabled configuration\n\n See @ref acc_config_enable_loopback_set\n\n @param[in] config The configuration\n @param[in] enable true if loopback to be enabled, false otherwise\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_enable_loopback_set(
        config: *mut acc_config_t,
        enable: bool,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the enable loopback configuration\n\n See @ref acc_config_enable_loopback_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return true if loopback is enabled, false otherwise"]
    pub fn acc_config_subsweep_enable_loopback_get(config: *const acc_config_t, index: u8) -> bool;
}
#[doc = " @brief Generic processing handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_processing_handle {
    _unused: [u8; 0],
}
pub type acc_processing_t = acc_processing_handle;
#[doc = " @brief Metadata that will be populated by the processing module during creation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_processing_metadata_t {
    #[doc = " Number of elements in the frame"]
    pub frame_data_length: u16,
    #[doc = " Number of elements in the sweep"]
    pub sweep_data_length: u16,
    #[doc = " Offset to the subsweeps data"]
    pub subsweep_data_offset: [u16; 4usize],
    #[doc = " Number of elements in the subsweeps"]
    pub subsweep_data_length: [u16; 4usize],
    #[doc = " Maximum sweep rate that the sensor can provide for the given configuration.\n  Note that this is not the actual exact sweep rate. To obtain an exact rate,\n  use the sweep rate parameter, @ref acc_config_sweep_rate_set.\n\n  If no max sweep rate is applicable, it's set to 0.0f."]
    pub max_sweep_rate: f32,
    #[doc = " Flag indicating if high speed mode is used.\n  If true, it means that the sensor has been configured in a way where it\n  can optimize its measurements and obtain a high max_sweep_rate.\n\n  Configuration limitations to enable high speed mode:\n\n  continuous_sweep_mode false, see @ref acc_config_continuous_sweep_mode_set\n  inter_sweep_idle_state READY, see @ref acc_config_inter_sweep_idle_state_set\n  num_subsweeps 1, see @ref acc_config_num_subsweeps_set\n  profile 3-5, see @ref acc_config_profile_set"]
    pub high_speed_mode: bool,
}
#[test]
fn bindgen_test_layout_acc_processing_metadata_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_processing_metadata_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_processing_metadata_t>(),
        28usize,
        concat!("Size of: ", stringify!(acc_processing_metadata_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_processing_metadata_t>(),
        4usize,
        concat!("Alignment of ", stringify!(acc_processing_metadata_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_data_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(frame_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sweep_data_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(sweep_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsweep_data_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(subsweep_data_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsweep_data_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(subsweep_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_sweep_rate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(max_sweep_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high_speed_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(high_speed_mode)
        )
    );
}
#[doc = " @brief Result provided by the processing module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_processing_result_t {
    #[doc = " Indication of sensor data being saturated, can cause data corruption.\n  Lower the receiver gain if this indication is set."]
    pub data_saturated: bool,
    #[doc = " Indication of a delayed frame.\n  The frame rate might need to be lowered if this indication is set."]
    pub frame_delayed: bool,
    #[doc = " Indication of calibration needed\n  The sensor calibration needs to be redone if this indication is set."]
    pub calibration_needed: bool,
    #[doc = " Temperature in sensor during measurement (in degree Celsius).\n  Note that it has poor absolute accuracy and should only be used\n  for relative temperature measurements."]
    pub temperature: i16,
    #[doc = " Pointer to the frame data"]
    pub frame: *mut acc_int16_complex_t,
}
#[test]
fn bindgen_test_layout_acc_processing_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_processing_result_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_processing_result_t>(),
        16usize,
        concat!("Size of: ", stringify!(acc_processing_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_processing_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(acc_processing_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_saturated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(data_saturated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_delayed) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(frame_delayed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calibration_needed) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(calibration_needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(frame)
        )
    );
}
extern "C" {
    #[doc = " @brief Create a processing instance with the provided configuration\n\n @param[in] config The configuration to create a processing instance with\n @param[out] processing_metadata The metadata of the created processing instance\n @return Processing handle, NULL if processing instance was not possible to create"]
    pub fn acc_processing_create(
        config: *const acc_config_t,
        processing_metadata: *mut acc_processing_metadata_t,
    ) -> *mut acc_processing_t;
}
extern "C" {
    #[doc = " @brief Process the data according to the configuration used in create\n\n @param[in] handle  A reference to the processing handle\n @param[in] buffer  A reference to the buffer (populated by @ref acc_sensor_read) containing the\n                    data to be processed.\n\n @param[out] result Processing result"]
    pub fn acc_processing_execute(
        handle: *mut acc_processing_t,
        buffer: *mut cty::c_void,
        result: *mut acc_processing_result_t,
    );
}
extern "C" {
    #[doc = " @brief Destroy a processing instance identified with the provided processing handle\n\n @param[in] handle A reference to the processing handle to destroy, can be NULL"]
    pub fn acc_processing_destroy(handle: *mut acc_processing_t);
}
extern "C" {
    #[doc = " @brief Convert a distance or step length in points to meter\n\n Does not include any zero-point offset since it is highly integration dependant. In other words,\n calling this function with a 0 always returns 0.0.\n\n @param[in] points Number of points to convert to meter\n @return The corresponding length in meters"]
    pub fn acc_processing_points_to_meter(points: i32) -> f32;
}
extern "C" {
    #[doc = " @brief Convert a distance or step length in meter to points\n\n Does not include any zero-point offset since it is highly integration dependant. In other words,\n calling this function with a 0.0 always returns 0.\n\n @param[in] length Length in meter to convert to points\n @return The corresponding length in points"]
    pub fn acc_processing_meter_to_points(length: f32) -> i32;
}
#[doc = " @defgroup service Service\n\n @brief Service API\n\n @defgroup sensor Sensor\n @ingroup service\n\n @brief Module to control the sensor\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_sensor {
    _unused: [u8; 0],
}
pub type acc_sensor_t = acc_sensor;
extern "C" {
    #[doc = " @brief Create a sensor instance\n\n A sensor instance represents a physical radar sensor and handles the communication\n with it.\n\n Before this function is called the sensor must be powered on and not used\n in another sensor instance without a power or reset cycle between.\n\n @param[in] sensor_id The sensor id to be used to communicate with\n\n @return Sensor instance, NULL if sensor instance was not possible to create"]
    pub fn acc_sensor_create(sensor_id: acc_sensor_id_t) -> *mut acc_sensor_t;
}
extern "C" {
    #[doc = " @brief Destroy a sensor instance freeing any resources allocated.\n\n @param[in] sensor The sensor instance to destroy, can be NULL"]
    pub fn acc_sensor_destroy(sensor: *mut acc_sensor_t);
}
extern "C" {
    #[doc = " @brief Calibrate a sensor\n\n Note that the sensor must be powered on before calling this function.\n To calibrate the sensor, call this function and wait for sensor interrupt,\n repeat until calibration is complete (or fails).\n\n @param[in]  sensor The sensor instance to calibrate\n @param[out] cal_complete True if calibration is complete\nFalse if caller should wait for interrupt and\nthen call again\n @param[out] cal_result The result after a completed calibration\n @param[in]  buffer Memory used during calibration.\n             A larger buffer might mean fewer transactions between host and sensor.\n             The buffer will only be used during the calibration.\n             The client has to make sure this buffer is suitably aligned for\n             any built-in type.\n @param[in]  buffer_size The size in bytes of the buffer, should be at least buffer_size\nfrom @ref acc_rss_get_buffer_size\n @return true if successful, false otherwise"]
    pub fn acc_sensor_calibrate(
        sensor: *mut acc_sensor_t,
        cal_complete: *mut bool,
        cal_result: *mut acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Gets calibration information from a calibration result\n\n @param[in]  cal_result The calibration result\n @param[out] cal_info The calibration information\n @return true if successful, false otherwise"]
    pub fn acc_sensor_get_cal_info(
        cal_result: *const acc_cal_result_t,
        cal_info: *mut acc_cal_info_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Prepare a sensor to do a measurement\n\n It's possible to reconfigure the sensor by calling the function multiple times.\n\n Note:\n - The sensor must be powered on when calling this function.\n - The sensor must not be measuring when calling this function, if previous call was\n   @ref acc_sensor_measure use @ref acc_hal_integration_wait_for_sensor_interrupt to\n   wait for measurement to complete.\n - Reconfiguring is not supported when double buffering is active, however enabling\n   double buffering through reconfiguration is.\n\n @param[in] sensor The sensor instance to prepare\n @param[in] config The configuration to prepare for\n @param[in] cal_result The calibration result to prepare for\n @param[in] buffer Memory used during preparation.\n            A larger buffer might mean fewer transactions between host and sensor.\n            The buffer will only be used during the duration of this call.\n            The client has to make sure this buffer is suitably aligned for\n            any built-in type.\n @param[in] buffer_size The size in bytes of the buffer, should be at least buffer_size\n            from @ref acc_rss_get_buffer_size\n @return true if successful, false otherwise"]
    pub fn acc_sensor_prepare(
        sensor: *mut acc_sensor_t,
        config: *const acc_config_t,
        cal_result: *const acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Start a radar measurement with previously prepared configuration\n\n Note that the following preconditions apply\n  - The sensor must be powered on\n  - @ref acc_sensor_calibrate must have been called\n  - @ref acc_sensor_prepare must have been called\n\n @param[in] sensor The sensor instance to measure with\n @return true if successful, false otherwise"]
    pub fn acc_sensor_measure(sensor: *mut acc_sensor_t) -> bool;
}
extern "C" {
    #[doc = " @brief Read out radar data\n\n Note that the following preconditions apply\n  - The sensor must be powered on\n  - @ref acc_sensor_measure must be called before each call to this function\n  - The sensor interrupt must be active\n\n @param[in] sensor The sensor to read the radar data from\n @param[in] buffer The buffer to read radar data into.\n            The buffer will only be used during the duration of this call.\n            The client has to make sure this buffer is suitably aligned for\n            any built-in type.\n @param[in] buffer_size The size in bytes of the buffer, should be at least buffer_size\n            from @ref acc_rss_get_buffer_size\n @return true if successful, false otherwise"]
    pub fn acc_sensor_read(
        sensor: *const acc_sensor_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if a sensor is connected and responsive\n\n Note that the sensor must be powered on before calling this function.\n\n @param[in] sensor_id The sensor id to be used to communicate with\n @return true if it is possible to communicate with the sensor"]
    pub fn acc_sensor_connected(sensor_id: acc_sensor_id_t) -> bool;
}
extern "C" {
    #[doc = " @brief Check the status of the sensor\n\n This function reads out the internal status from the sensor and prints it for debugging purposes.\n It can for example be called when the function @ref acc_hal_integration_wait_for_sensor_interrupt()\n fails. Note that the sensor must be powered on before calling this function.\n\n @param[in] sensor The sensor instance to get status from"]
    pub fn acc_sensor_status(sensor: *const acc_sensor_t);
}
extern "C" {
    #[doc = " @brief Prepare sensor for entering hibernation\n\n Prepare sensor for entering hibernation.\n Should be invoked prior to calling @ref acc_hal_integration_sensor_disable()\n\n @param[in] sensor The sensor to prepare for hibernation\n @return True if prepare was successful"]
    pub fn acc_sensor_hibernate_on(sensor: *mut acc_sensor_t) -> bool;
}
extern "C" {
    #[doc = " @brief Restore sensor after exiting hibernation\n\n Restore sensor after exiting hibernation.\n Should be invoked after calling @ref acc_hal_integration_sensor_enable()\n\n @param[in] sensor The sensor to unprepare for hibernation\n @return True if unprepare was successful"]
    pub fn acc_sensor_hibernate_off(sensor: *const acc_sensor_t) -> bool;
}
extern "C" {
    #[doc = " @brief Validate calibration result\n\n @param[in] cal_result Result of a calibration\n\n @return True if calibration is valid"]
    pub fn acc_sensor_validate_calibration(cal_result: *const acc_cal_result_t) -> bool;
}
#[doc = " @brief Presence detector handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_detector_presence_handle {
    _unused: [u8; 0],
}
pub type acc_detector_presence_handle_t = acc_detector_presence_handle;
#[doc = " @brief Presence detector configuration container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_detector_presence_config {
    _unused: [u8; 0],
}
pub type acc_detector_presence_config_t = acc_detector_presence_config;
#[doc = " @brief Presence detector results container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_detector_presence_result_t {
    #[doc = " true if presence was detected, false otherwise"]
    pub presence_detected: bool,
    #[doc = " A measure of the amount of fast motion detected"]
    pub intra_presence_score: f32,
    #[doc = " A measure of the amount of slow motion detected"]
    pub inter_presence_score: f32,
    #[doc = " The distance, in meters, to the detected object"]
    pub presence_distance: f32,
    #[doc = " An array of measures of the amount of fast motion detected per distance point.\n This will point to memory in the buffer supplied to @ref acc_detector_presence_process"]
    pub depthwise_intra_presence_scores: *mut f32,
    #[doc = " An array of measures of the amount of slow motion detected per distance point.\n This will point to memory in the buffer supplied to @ref acc_detector_presence_process"]
    pub depthwise_inter_presence_scores: *mut f32,
    #[doc = " The number of elements in the depthwise presence scores arrays"]
    pub depthwise_presence_scores_length: u32,
    #[doc = " Radar data that the presence detection is based on.\n This will point to memory in the buffer supplied to @ref acc_detector_presence_process"]
    pub processing_result: acc_processing_result_t,
}
#[test]
fn bindgen_test_layout_acc_detector_presence_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_detector_presence_result_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_detector_presence_result_t>(),
        56usize,
        concat!("Size of: ", stringify!(acc_detector_presence_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_detector_presence_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(acc_detector_presence_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).presence_detected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(presence_detected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intra_presence_score) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(intra_presence_score)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inter_presence_score) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(inter_presence_score)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).presence_distance) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(presence_distance)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).depthwise_intra_presence_scores) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(depthwise_intra_presence_scores)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).depthwise_inter_presence_scores) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(depthwise_inter_presence_scores)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).depthwise_presence_scores_length) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(depthwise_presence_scores_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).processing_result) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_result_t),
            "::",
            stringify!(processing_result)
        )
    );
}
#[doc = " brief Metadata for presence detector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_detector_presence_metadata_t {
    #[doc = " Actual start point of measurement in m.\n This can be useful to know the exact start point of the measurement in m.\n The resolution of each point is approximately 2.5mm"]
    pub start_m: f32,
    #[doc = " Actual step length between each data point of the measurement in m.\n This can be useful when automatic selection of step length based on the profile\n is enabled through @ref acc_detector_presence_config_auto_step_length_set"]
    pub step_length_m: f32,
    #[doc = " Number of data points in measurement.\n This is calculated from the requested start and end point and the resulting\n step length. This corresponds to the length of the depthwise inter/intra\n presence score results, which can be useful to know already at detector creation."]
    pub num_points: u16,
    #[doc = " Profile used.\n This can be useful when automatic selection of profile based on start point\n is enabled through @ref acc_detector_presence_config_auto_profile_set"]
    pub profile: acc_config_profile_t,
}
#[test]
fn bindgen_test_layout_acc_detector_presence_metadata_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_detector_presence_metadata_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_detector_presence_metadata_t>(),
        16usize,
        concat!("Size of: ", stringify!(acc_detector_presence_metadata_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_detector_presence_metadata_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(acc_detector_presence_metadata_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_metadata_t),
            "::",
            stringify!(start_m)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).step_length_m) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_metadata_t),
            "::",
            stringify!(step_length_m)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_metadata_t),
            "::",
            stringify!(num_points)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_presence_metadata_t),
            "::",
            stringify!(profile)
        )
    );
}
extern "C" {
    #[doc = " @brief Create a configuration for a presence detector\n\n @return Presence detector configuration, NULL if creation was not possible"]
    pub fn acc_detector_presence_config_create() -> *mut acc_detector_presence_config_t;
}
extern "C" {
    #[doc = " @brief Destroy a presence detector configuration\n\n @param[in] presence_config The configuration to destroy"]
    pub fn acc_detector_presence_config_destroy(
        presence_config: *mut acc_detector_presence_config_t,
    );
}
extern "C" {
    #[doc = " @brief Print a configuration to the log\n\n @param[in] presence_config The configuration to log"]
    pub fn acc_detector_presence_config_log(presence_config: *const acc_detector_presence_config_t);
}
extern "C" {
    #[doc = " @brief Get the buffer size needed for the provided presence detector handle\n\n This buffer size can be used to allocate a memory buffer in the\n application, which is needed for several functions in the detector library.\n This size will also include memory for holding the depthwise inter/intra presence\n score arrays that will be part of the result, see @ref acc_detector_presence_result_t\n\n @param[in] presence_handle The presence detector handle to to get the buffer size for\n @param[out] buffer_size The buffer size\n @return true if successful, false otherwise"]
    pub fn acc_detector_presence_get_buffer_size(
        presence_handle: *const acc_detector_presence_handle_t,
        buffer_size: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Create a presence detector with the provided configuration\n\n @param[in] presence_config The presence detector configuration to create a presence detector with\n @param[out] metadata Metadata for the presence detector given the presence_config\n @return Presence detector handle, NULL if presence detector was not possible to create"]
    pub fn acc_detector_presence_create(
        presence_config: *mut acc_detector_presence_config_t,
        metadata: *mut acc_detector_presence_metadata_t,
    ) -> *mut acc_detector_presence_handle_t;
}
extern "C" {
    #[doc = " @brief Destroy a presence detector identified with the provided handle\n\n Destroy the context of a presence detector allowing another presence detector to be created using the\n same resources.\n If NULL is sent in, nothing happens.\n\n @param[in] presence_handle A reference to the presence detector handle to destroy"]
    pub fn acc_detector_presence_destroy(presence_handle: *mut acc_detector_presence_handle_t);
}
extern "C" {
    #[doc = " @brief Prepare the detector to do a measurement\n\n @param[in] presence_handle The presence detector handle to prepare for\n @param[in] presence_config The configuration to prepare with\n @param[in] sensor The sensor instance to prepare\n @param[in] cal_result The calibration result to prepare with\n @param[in] buffer Memory used by the detector to prepare the sensor for measurements\n            The buffer will only be used during the duration of this call\n @param[in] buffer_size The size in bytes of the buffer, should be at least buffer_size\n            from @ref acc_detector_presence_get_buffer_size\n @return true if successful, false otherwise"]
    pub fn acc_detector_presence_prepare(
        presence_handle: *mut acc_detector_presence_handle_t,
        presence_config: *mut acc_detector_presence_config_t,
        sensor: *mut acc_sensor_t,
        cal_result: *const acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Process the data according to the configuration used in @ref acc_detector_presence_config_create\n\n @param[in] presence_handle The presence detector handle for the presence detector to get the next result for\n @param[in] buffer  A reference to the buffer (populated by @ref acc_sensor_read) containing the\n                    data to be processed.\n                    After this function returns, the depthwise inter/intra presence that is part of the\n                    result (@ref acc_detector_presence_result_t) will point to memory located in this buffer.\n                    If these arrays are of interest for the application they need to be processed\n                    before the buffer is used in any other function.\n @param[out] result Presence detector results\n @return true if successful, otherwise false"]
    pub fn acc_detector_presence_process(
        presence_handle: *mut acc_detector_presence_handle_t,
        buffer: *mut cty::c_void,
        result: *mut acc_detector_presence_result_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the start point of measurement interval in meters\n\n @param[in] presence_config The configuration\n @param[in] start The start point of measurement interval in meters"]
    pub fn acc_detector_presence_config_start_set(
        presence_config: *mut acc_detector_presence_config_t,
        start: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the start point of measurement interval in meters\n\n @param[in] presence_config The configuration\n @return The start point of measurement interval in meters"]
    pub fn acc_detector_presence_config_start_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the end point of measurement interval in meters\n\n @param[in] presence_config The configuration\n @param[in] end The end point of measurement interval in meters"]
    pub fn acc_detector_presence_config_end_set(
        presence_config: *mut acc_detector_presence_config_t,
        end: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the end point of measurement interval in meters\n\n @param[in] presence_config The configuration\n @return The end point of measurement interval in meters"]
    pub fn acc_detector_presence_config_end_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the step length in points\n\n This sets the number of steps between each data point.\n\n The set step length will only be used if step length auto selection was disabled\n through @ref acc_detector_presence_config_auto_step_length_set\n\n Sampling produces complex (IQ) data points with configurable distance spacing,\n starting from ~2.5mm.\n\n @param[in] presence_config The configuration\n @param[in] step_length The step length"]
    pub fn acc_detector_presence_config_step_length_set(
        presence_config: *mut acc_detector_presence_config_t,
        step_length: u16,
    );
}
extern "C" {
    #[doc = " @brief Get the step length in points\n\n @see acc_detector_presence_config_step_length_set\n\n @param[in] presence_config The configuration\n @return The step length"]
    pub fn acc_detector_presence_config_step_length_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Enable automatic selection of step length based on the profile\n\n The highest possible step length based on the fwhm of the set profile\n with the goal to achieve detection on the complete range with minimum number\n of sampling points\n\n @param[in] presence_config The configuration\n @param[in] enable true to enable auto selection, false to disable"]
    pub fn acc_detector_presence_config_auto_step_length_set(
        presence_config: *mut acc_detector_presence_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if automatic selection of step length based on the profile is enabled\n\n See @ref acc_detector_presence_config_auto_step_length_set\n\n @param[in] presence_config The configuration\n @return true if automatic selection of step length is enabled, false if disabled"]
    pub fn acc_detector_presence_config_auto_step_length_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set a profile\n\n Each profile consists of a number of settings for the sensor that configures\n the RX and TX paths. Lower profiles have higher depth resolution while\n higher profiles have higher SNR.\n\n The set profile will only be used if profile auto selection was disabled\n through @ref acc_detector_presence_config_auto_profile_set\n\n @param[in] presence_config The configuration\n @param[in] profile The profile to set"]
    pub fn acc_detector_presence_config_profile_set(
        presence_config: *mut acc_detector_presence_config_t,
        profile: acc_config_profile_t,
    );
}
extern "C" {
    #[doc = " @brief Get the currently set profile\n\n See @ref acc_detector_presence_config_profile_set\n\n @param[in] presence_config The configuration\n @return The profile currently used"]
    pub fn acc_detector_presence_config_profile_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> acc_config_profile_t;
}
extern "C" {
    #[doc = " @brief Enable automatic selection of profile based on start point of measurement\n\n The highest possible profile without interference of direct leakage will used to maximize SNR\n\n @param[in] presence_config The configuration\n @param[in] enable true to enable auto selection, false to disable"]
    pub fn acc_detector_presence_config_auto_profile_set(
        presence_config: *mut acc_detector_presence_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if automatic selection of profile based on start point of measurement is enabled\n\n See @ref acc_detector_presence_config_auto_profile_set\n\n @param[in] presence_config The configuration\n @return true if automatic selection of profile is enabled, false if disabled"]
    pub fn acc_detector_presence_config_auto_profile_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set inter frame idle state\n\n The 'inter-frame idle state' is the state the sensor idles in between each frame.\n\n See also @ref acc_config_idle_state_t.\n\n @param[in] presence_config The configuration\n @param[in] idle_state The idle state to use between frames"]
    pub fn acc_detector_presence_config_inter_frame_idle_state_set(
        presence_config: *mut acc_detector_presence_config_t,
        idle_state: acc_config_idle_state_t,
    );
}
extern "C" {
    #[doc = " @brief Get inter frame idle state\n\n See @ref acc_detector_presence_config_inter_frame_idle_state_set\n\n @param[in] presence_config The configuration\n @return The idle state to use between frames"]
    pub fn acc_detector_presence_config_inter_frame_idle_state_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> acc_config_idle_state_t;
}
extern "C" {
    #[doc = " @brief Set the hardware accelerated average samples (HWAAS)\n\n See @ref acc_config_hwaas_set for more details\n\n @param[in] presence_config The configuration\n @param[in] hwaas Hardware accelerated average samples"]
    pub fn acc_detector_presence_config_hwaas_set(
        presence_config: *mut acc_detector_presence_config_t,
        hwaas: u16,
    );
}
extern "C" {
    #[doc = " @brief Get the hardware accelerated average samples (HWAAS)\n\n See @ref acc_detector_presence_config_hwaas_set\n\n @param[in] presence_config The configuration\n @return Hardware accelerated average samples"]
    pub fn acc_detector_presence_config_hwaas_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Set the number of sweeps per frame\n\n Sets the number of sweeps that will be captured in each frame (measurement).\n\n @param[in] presence_config The configuration\n @param[in] sweeps_per_frame Sweeps per frame, must be at least 6"]
    pub fn acc_detector_presence_config_sweeps_per_frame_set(
        presence_config: *mut acc_detector_presence_config_t,
        sweeps_per_frame: u16,
    );
}
extern "C" {
    #[doc = " @brief Get the number of sweeps per frame\n\n See @ref acc_detector_presence_config_sweeps_per_frame_set\n\n @param[in] presence_config The configuration\n @return Sweeps per frame"]
    pub fn acc_detector_presence_config_sweeps_per_frame_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Set the frame rate\n\n This frame rate is maintained by the sensor if @ref acc_detector_presence_config_frame_rate_app_driven_set\n is invoked with false (default) and the application must maintain the given frame rate if invoked with true.\n If the application maintains the frame rate it is important that it doesn't deviate more than 10%\n from the set value for the presence algorithm to work optimally.\n See @ref acc_config_frame_rate_set for details\n\n @param[in] presence_config The configuration\n @param[in] frame_rate Frame rate in Hz. Must be > 0"]
    pub fn acc_detector_presence_config_frame_rate_set(
        presence_config: *mut acc_detector_presence_config_t,
        frame_rate: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the frame rate\n\n See @ref acc_detector_presence_config_frame_rate_set\n\n @param[in] presence_config The configuration\n @return Frame rate in Hz"]
    pub fn acc_detector_presence_config_frame_rate_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set if the application should maintain the requested frame rate\n\n If set to true, the application must maintain the frame rate set using\n @ref acc_detector_presence_config_frame_rate_set\n If set to false, the frame rate is maintained by the sensor at the frame rate given by\n @ref acc_detector_presence_config_frame_rate_set.\n\n @param[in] presence_config The configuration\n @param[in] enable true to enable application driven frame rate, false to disable"]
    pub fn acc_detector_presence_config_frame_rate_app_driven_set(
        presence_config: *mut acc_detector_presence_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if the application should maintain the requested frame rate\n\n See @ref acc_detector_presence_config_frame_rate_app_driven_set\n\n @param[in] presence_config The configuration\n @return true if application driven frame rate is enabled, false if disabled"]
    pub fn acc_detector_presence_config_frame_rate_app_driven_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set sensor ID\n\n @param[in] presence_config The configuration to set the sensor ID for\n @param[in] sensor_id The sensor ID"]
    pub fn acc_detector_presence_config_sensor_set(
        presence_config: *mut acc_detector_presence_config_t,
        sensor_id: acc_sensor_id_t,
    );
}
extern "C" {
    #[doc = " @brief Get sensor ID\n\n @param[in] presence_config The configuration to get the sensor ID for\n @return sensor ID"]
    pub fn acc_detector_presence_config_sensor_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> acc_sensor_id_t;
}
extern "C" {
    #[doc = " @brief Set if the presence filters should reset on prepare\n\n If set to true, the presence filters will be reset when\n @ref acc_detector_presence_prepare is invoked.\n\n @param[in] presence_config The configuration\n @param[in] enable true to reset the filters on prepare, false to not reset"]
    pub fn acc_detector_presence_config_reset_filters_on_prepare_set(
        presence_config: *mut acc_detector_presence_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if the presence filters should reset on prepare\n\n See @ref acc_detector_presence_config_reset_filters_on_prepare_set\n\n @param[in] presence_config The configuration\n @return true if filters should reset on prepare, false otherwise"]
    pub fn acc_detector_presence_config_reset_filters_on_prepare_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the inter-frame presence timeout in seconds\n\n Number of seconds the inter-frame presence score needs to decrease before exponential\n scaling starts for faster decline. Should be between 0 and 30 where 0 means no timeout\n\n @param[in] presence_config The configuration\n @param[in] inter_frame_presence_timeout Timeout in seconds between 0 and 30"]
    pub fn acc_detector_presence_config_inter_frame_presence_timeout_set(
        presence_config: *mut acc_detector_presence_config_t,
        inter_frame_presence_timeout: u16,
    );
}
extern "C" {
    #[doc = " @brief Get the inter-frame presence timeout in seconds\n\n See @ref acc_detector_presence_config_inter_frame_presence_timeout_set\n\n @param[in] presence_config The configuration\n @return Inter-frame presence timeout in s"]
    pub fn acc_detector_presence_config_inter_frame_presence_timeout_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Set inter-frame phase boost\n\n Used to increase detection of slow motions by utilizing the phase information in the Sparse IQ data.\n\n @param[in] presence_config The configuration to set inter phase boost for\n @param[in] enable true if inter phase boost should be enabled"]
    pub fn acc_detector_presence_config_inter_phase_boost_set(
        presence_config: *mut acc_detector_presence_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if inter-frame phase boost is enabled\n\n See @ref acc_detector_presence_config_inter_phase_boost_set\n\n @param[in] presence_config The configuration to get inter phase boost for\n @return true if inter-frame phase boost is enabled, false otherwise"]
    pub fn acc_detector_presence_config_inter_phase_boost_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set intra-frame presence detection\n\n This is used for detecting faster movements inside frames\n\n @param[in] presence_config The configuration to set intra-frame detection for\n @param[in] enable true if intra-frame detection should be enabled"]
    pub fn acc_detector_presence_config_intra_detection_set(
        presence_config: *mut acc_detector_presence_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if frame intra-frame presence detection is enabled\n\n See @ref acc_detector_presence_config_intra_detection_set\n\n @param[in] presence_config The configuration to get intra detection for\n @return true if intra-frame detection is enabled, false otherwise"]
    pub fn acc_detector_presence_config_intra_detection_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the detection threshold for the intra-frame presence detection\n\n This is the threshold for detecting faster movements inside frames\n\n @param[in] presence_config The configuration to set the detection threshold for\n @param[in] intra_detection_threshold The intra-frame detection threshold to set"]
    pub fn acc_detector_presence_config_intra_detection_threshold_set(
        presence_config: *mut acc_detector_presence_config_t,
        intra_detection_threshold: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the detection threshold for the intra-frame presence detection\n\n See @ref acc_detector_presence_config_intra_detection_threshold_set\n\n @param[in] presence_config The configuration to get the detection threshold for\n @return The intra-frame detection threshold"]
    pub fn acc_detector_presence_config_intra_detection_threshold_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set inter-frame presence detection\n\n This is used for detecting slower movements between frames\n\n @param[in] presence_config The configuration to set inter-frame detection for\n @param[in] enable true if inter-frame presence detection should be enabled"]
    pub fn acc_detector_presence_config_inter_detection_set(
        presence_config: *mut acc_detector_presence_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if inter-frame presence detection is enabled\n\n See @ref acc_detector_presence_config_inter_detection_set\n\n @param[in] presence_config The configuration to get inter-frame presence detection for\n @return true if inter-frame presence detection is enabled, false otherwise"]
    pub fn acc_detector_presence_config_inter_detection_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the detection threshold for the inter-frame presence detection\n\n This is the threshold for detecting slower movements between frames\n\n @param[in] presence_config The configuration to set the detection threshold for\n @param[in] inter_detection_threshold The threshold"]
    pub fn acc_detector_presence_config_inter_detection_threshold_set(
        presence_config: *mut acc_detector_presence_config_t,
        inter_detection_threshold: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the detection threshold for the inter-frame presence detection\n\n See @ref acc_detector_presence_config_inter_detection_threshold_set\n\n @param[in] presence_config The configuration to get the detection threshold for\n @return detection threshold"]
    pub fn acc_detector_presence_config_inter_detection_threshold_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the time constant of the low pass filter for the inter-frame deviation between fast and slow\n\n @param[in] presence_config The configuration\n @param[in] inter_frame_deviation_time_const Time constant to set"]
    pub fn acc_detector_presence_config_inter_frame_deviation_time_const_set(
        presence_config: *mut acc_detector_presence_config_t,
        inter_frame_deviation_time_const: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the time constant of the low pass filter for the inter-frame deviation between fast and slow\n\n @param[in] presence_config The configuration to get the time constant for\n @return time constant in s"]
    pub fn acc_detector_presence_config_inter_frame_deviation_time_const_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the cutoff frequency of the low pass filter for the fast filtered absolute sweep mean\n\n No filtering is applied if the cutoff is set over half the frame rate (Nyquist limit).\n\n @param[in] presence_config The configuration\n @param[in] inter_frame_fast_cutoff Cutoff frequency to set"]
    pub fn acc_detector_presence_config_inter_frame_fast_cutoff_set(
        presence_config: *mut acc_detector_presence_config_t,
        inter_frame_fast_cutoff: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the cutoff frequency of the low pass filter for the fast filtered absolute sweep mean\n\n @param[in] presence_config The configuration to get the cutoff frequency for\n @return the cutoff frequency in Hz"]
    pub fn acc_detector_presence_config_inter_frame_fast_cutoff_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the cutoff frequency of the low pass filter for the slow filtered absolute sweep mean\n\n @param[in] presence_config The configuration\n @param[in] inter_frame_slow_cutoff Cutoff frequency to set"]
    pub fn acc_detector_presence_config_inter_frame_slow_cutoff_set(
        presence_config: *mut acc_detector_presence_config_t,
        inter_frame_slow_cutoff: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the cutoff frequency of the low pass filter for the slow filtered absolute sweep mean\n\n @param[in] presence_config The configuration to get the cutoff frequency for\n @return the cutoff frequency in Hz"]
    pub fn acc_detector_presence_config_inter_frame_slow_cutoff_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the time constant for the depthwise filtering in the intra-frame part\n\n @param[in] presence_config The configuration\n @param[in] intra_frame_time_const Time constant to set"]
    pub fn acc_detector_presence_config_intra_frame_time_const_set(
        presence_config: *mut acc_detector_presence_config_t,
        intra_frame_time_const: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the time constant for the depthwise filtering in the intra-frame part\n\n @param[in] presence_config The configuration to get the time constant for\n @return time constant in s"]
    pub fn acc_detector_presence_config_intra_frame_time_const_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the time constant for the output in the intra-frame part\n\n @param[in] presence_config The configuration\n @param[in] intra_output_time_const Time constant to set"]
    pub fn acc_detector_presence_config_intra_output_time_const_set(
        presence_config: *mut acc_detector_presence_config_t,
        intra_output_time_const: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the time constant for the output in the intra-frame part\n\n @param[in] presence_config The configuration to get the time constant for\n @return time constant in s"]
    pub fn acc_detector_presence_config_intra_output_time_const_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the time constant for the output in the inter-frame part\n\n @param[in] presence_config The configuration\n @param[in] inter_output_time_const Time constant to set"]
    pub fn acc_detector_presence_config_inter_output_time_const_set(
        presence_config: *mut acc_detector_presence_config_t,
        inter_output_time_const: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the time constant for the output in the inter-frame part\n\n @param[in] presence_config The configuration to get the time constant for\n @return time constant in s"]
    pub fn acc_detector_presence_config_inter_output_time_const_get(
        presence_config: *const acc_detector_presence_config_t,
    ) -> f32;
}
