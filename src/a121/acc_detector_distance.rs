/* automatically generated by rust-bindgen 0.69.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ACC_CAL_RESULT_DATA_SIZE: u32 = 192;
pub const ACC_MAX_NUM_SUBSWEEPS: u32 = 4;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const PRIsensor_id: &[u8; 2] = b"u\0";
pub const ACC_DETECTOR_DISTANCE_RESULT_MAX_NUM_DISTANCES: u32 = 10;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __suseconds64_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " The result from a completed calibration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_cal_result_t {
    pub data: [u8; 192usize],
}
#[test]
fn bindgen_test_layout_acc_cal_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_cal_result_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_cal_result_t>(),
        192usize,
        concat!("Size of: ", stringify!(acc_cal_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_cal_result_t>(),
        1usize,
        concat!("Alignment of ", stringify!(acc_cal_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_cal_result_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Information about calibration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_cal_info_t {
    pub temperature: i16,
}
#[test]
fn bindgen_test_layout_acc_cal_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_cal_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_cal_info_t>(),
        2usize,
        concat!("Size of: ", stringify!(acc_cal_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_cal_info_t>(),
        2usize,
        concat!("Alignment of ", stringify!(acc_cal_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_cal_info_t),
            "::",
            stringify!(temperature)
        )
    );
}
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_1: acc_config_profile_t = 1;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_2: acc_config_profile_t = 2;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_3: acc_config_profile_t = 3;
#[doc = " The profile with the highest depth resolution and lowest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_4: acc_config_profile_t = 4;
#[doc = " The profile with the lowest depth resolution and highest radar loop gain."]
pub const acc_config_profile_t_ACC_CONFIG_PROFILE_5: acc_config_profile_t = 5;
#[doc = " @brief Profile\n\n Each profile consists of a number of settings for the sensor that configures the RX and TX paths.\n Lower profiles have higher depth resolution while higher profiles have higher radar loop gain."]
pub type acc_config_profile_t = cty::c_uint;
#[doc = " The deepest state where as much of the sensor hardware is shut down."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_DEEP_SLEEP: acc_config_idle_state_t = 0;
#[doc = " The deepest state where as much of the sensor hardware is shut down."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_SLEEP: acc_config_idle_state_t = 1;
#[doc = " The shallowest state where most of the sensor hardware is kept on."]
pub const acc_config_idle_state_t_ACC_CONFIG_IDLE_STATE_READY: acc_config_idle_state_t = 2;
#[doc = " @brief Idle state\n\n Idle state 'DEEP_SLEEP' is the deepest state where as much of the sensor hardware as\n possible is shut down and idle state 'READY' is the shallowest state where most of the sensor\n hardware is kept on.\n\n DEEP_SLEEP is the slowest to transition from while READY is the fastest.\n"]
pub type acc_config_idle_state_t = cty::c_uint;
#[doc = " 19.5 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_19_5_MHZ: acc_config_prf_t = 0;
#[doc = " 15.6 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_15_6_MHZ: acc_config_prf_t = 1;
#[doc = " 13.0 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_13_0_MHZ: acc_config_prf_t = 2;
#[doc = " 8.7 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_8_7_MHZ: acc_config_prf_t = 3;
#[doc = " 6.5 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_6_5_MHZ: acc_config_prf_t = 4;
#[doc = " 5.2 MHz"]
pub const acc_config_prf_t_ACC_CONFIG_PRF_5_2_MHZ: acc_config_prf_t = 5;
#[doc = " @brief Pulse Repetition Frequency\n\n Pulse Repetition Frequency, PRF, is the frequency at\n which pulses are sent out from the radar system. The\n measurement time is approximately proportional to the\n PRF. The higher the PRF, the shorter the measurement time.\n\n This parameter sets the Maximum Measurable Distance, MMD,\n that can be achieved. MMD is the maximum value for the end point,\n i.e.,the start point + (number of points * step length).\n For example, an MMD of 7.0 m means that the range cannot\n be set further out than 7.0 m.\n\n It also sets the Maximum Unambiguous Range, MUR, that can be achieved.\n MUR is the maximum distance at which an object can be located to guarantee\n that its reflection corresponds to the most recent transmitted pulse.\n Objects farther away than the MUR may fold into the measured range.\n For example, with a MUR of 11.5 m, an object at 13.5 m could become\n visible at 2 m.\n\n | PRF Setting              |      PRF |    MMD |    MUR |\n |-------------------------:|---------:|-------:|-------:|\n | ACC_CONFIG_PRF_19_5_MHZ* | 19.5 MHz |  3.1 m |  7.7 m |\n | ACC_CONFIG_PRF_15_6_MHZ  | 15.6 MHz |  5.1 m |  9.6 m |\n | ACC_CONFIG_PRF_13_0_MHZ  | 13.0 MHz |  7.0 m | 11.5 m |\n | ACC_CONFIG_PRF_8_7_MHZ   |  8.7 MHz | 12.7 m | 17.3 m |\n | ACC_CONFIG_PRF_6_5_MHZ   |  6.5 MHz | 18.5 m | 23.1 m |\n | ACC_CONFIG_PRF_5_2_MHZ   |  5.2 MHz | 24.3 m | 28.8 m |\n\n *19.5MHz is only available for profile 1."]
pub type acc_config_prf_t = cty::c_uint;
pub type __gwchar_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> uintmax_t;
}
#[doc = " @brief Type representing a sensor ID"]
pub type acc_sensor_id_t = u32;
#[doc = " ERROR log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_ERROR: acc_log_level_t = 0;
#[doc = " WARNING log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_WARNING: acc_log_level_t = 1;
#[doc = " INFO log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_INFO: acc_log_level_t = 2;
#[doc = " VERBOSE log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_VERBOSE: acc_log_level_t = 3;
#[doc = " DEBUG log level."]
pub const acc_log_level_t_ACC_LOG_LEVEL_DEBUG: acc_log_level_t = 4;
#[doc = " @brief This enum represents the different log levels for RSS"]
pub type acc_log_level_t = cty::c_uint;
#[doc = " @brief Data type for interger-based representation of complex numbers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_int16_complex_t {
    pub real: i16,
    pub imag: i16,
}
#[test]
fn bindgen_test_layout_acc_int16_complex_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_int16_complex_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_int16_complex_t>(),
        4usize,
        concat!("Size of: ", stringify!(acc_int16_complex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_int16_complex_t>(),
        2usize,
        concat!("Alignment of ", stringify!(acc_int16_complex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_int16_complex_t),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_int16_complex_t),
            "::",
            stringify!(imag)
        )
    );
}
#[doc = " Return peaks with the closest detection first."]
pub const acc_detector_distance_peak_sorting_t_ACC_DETECTOR_DISTANCE_PEAK_SORTING_CLOSEST:
    acc_detector_distance_peak_sorting_t = 0;
#[doc = " Return peaks with the peak with the highest RCS first."]
pub const acc_detector_distance_peak_sorting_t_ACC_DETECTOR_DISTANCE_PEAK_SORTING_STRONGEST:
    acc_detector_distance_peak_sorting_t = 1;
#[doc = " @brief Enum for peak sorting algorithms"]
pub type acc_detector_distance_peak_sorting_t = cty::c_uint;
#[doc = " Compares processed data against a fixed amplitude value"]
pub const acc_detector_distance_threshold_method_t_ACC_DETECTOR_DISTANCE_THRESHOLD_METHOD_FIXED_AMPLITUDE : acc_detector_distance_threshold_method_t = 0 ;
#[doc = " Compares processed data against a fixed strength value"]
pub const acc_detector_distance_threshold_method_t_ACC_DETECTOR_DISTANCE_THRESHOLD_METHOD_FIXED_STRENGTH : acc_detector_distance_threshold_method_t = 1 ;
#[doc = " Compares processed data against a recorded threshold"]
pub const acc_detector_distance_threshold_method_t_ACC_DETECTOR_DISTANCE_THRESHOLD_METHOD_RECORDED : acc_detector_distance_threshold_method_t = 2 ;
#[doc = " Uses the CFAR algorithm as a threshold"]
pub const acc_detector_distance_threshold_method_t_ACC_DETECTOR_DISTANCE_THRESHOLD_METHOD_CFAR:
    acc_detector_distance_threshold_method_t = 3;
#[doc = " @brief Enum for threshold methods"]
pub type acc_detector_distance_threshold_method_t = cty::c_uint;
#[doc = " Use a generic reflector shape for RCS calculation"]
pub const acc_detector_distance_reflector_shape_t_ACC_DETECTOR_DISTANCE_REFLECTOR_SHAPE_GENERIC:
    acc_detector_distance_reflector_shape_t = 0;
#[doc = " Use a planar reflector shape for RCS calculation"]
pub const acc_detector_distance_reflector_shape_t_ACC_DETECTOR_DISTANCE_REFLECTOR_SHAPE_PLANAR:
    acc_detector_distance_reflector_shape_t = 1;
#[doc = " @brief Enum for reflector shapes"]
pub type acc_detector_distance_reflector_shape_t = cty::c_uint;
#[doc = " @defgroup config Config\n @ingroup service\n\n @brief Module to configure sensor and processing\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_config {
    _unused: [u8; 0],
}
pub type acc_config_t = acc_config;
extern "C" {
    #[doc = " @brief Create a configuration\n\n A configuration is created and populated with default values.\n\n @return A configuration instance"]
    pub fn acc_config_create() -> *mut acc_config_t;
}
extern "C" {
    #[doc = " @brief Destroy a configuration freeing any resources allocated\n\n Destroy a configuration that is no longer needed.\n\n @param[in] config The configuration to destroy, can be NULL"]
    pub fn acc_config_destroy(config: *mut acc_config_t);
}
extern "C" {
    #[doc = " @brief Print a configuration to the log\n\n @param[in] config The configuration to log"]
    pub fn acc_config_log(config: *const acc_config_t);
}
extern "C" {
    #[doc = " @brief Set the starting point of the sweep\n\n This sets the starting point of the sweep. The corresponding start\n in millimeter is approximately start_point * 2.5 mm. For the exact\n distance in meter, use the @ref acc_processing_points_to_meter function.\n\n @param[in] config The configuration\n @param[in] start_point The starting point of the sweep"]
    pub fn acc_config_start_point_set(config: *mut acc_config_t, start_point: i32);
}
extern "C" {
    #[doc = " @brief Get the starting point of the sweep\n\n @see acc_config_start_point_set\n\n @param[in] config The configuration\n @return The starting point of the sweep"]
    pub fn acc_config_start_point_get(config: *const acc_config_t) -> i32;
}
extern "C" {
    #[doc = " @brief Set the number of data points to measure\n\n This sets the number of data points to measure in a sweep.\n\n @param[in] config The configuration\n @param[in] num_points Number of data points to measure"]
    pub fn acc_config_num_points_set(config: *mut acc_config_t, num_points: u16);
}
extern "C" {
    #[doc = " @brief Get the number of data points to measure\n\n @see acc_config_num_points_set\n\n @param[in] config The configuration\n @return Number of data points to measure"]
    pub fn acc_config_num_points_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set the step length in a sweep\n\n This sets the number of steps to have between each data point.\n\n Sampling produces complex (IQ) data points with configurable distance spacing,\n starting from ~2.5mm.\n\n @param[in] config The configuration\n @param[in] step_length The step length"]
    pub fn acc_config_step_length_set(config: *mut acc_config_t, step_length: u16);
}
extern "C" {
    #[doc = " @brief Get the step length in a sweep\n\n @see acc_config_step_length_set\n\n @param[in] config The configuration\n @return The step length"]
    pub fn acc_config_step_length_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set a profile\n\n Each profile consists of a number of settings for the sensor that configures\n the RX and TX paths. Lower profiles have higher depth resolution while\n higher profiles have higher SNR.\n\n @param[in] config The config to set a profile for\n @param[in] profile The profile to set"]
    pub fn acc_config_profile_set(config: *mut acc_config_t, profile: acc_config_profile_t);
}
extern "C" {
    #[doc = " @brief Get the currently used profile\n\n See @ref acc_config_profile_set\n\n @param[in] config The config to get a profile for\n @return The profile currently used"]
    pub fn acc_config_profile_get(config: *const acc_config_t) -> acc_config_profile_t;
}
extern "C" {
    #[doc = " @brief Set the hardware accelerated average samples (HWAAS)\n\n Each data point can be sampled several times and the sensor hardware then\n produces an average value of those samples. The time needed to measure a sweep is roughly proportional\n to the number of averaged samples. Hence, if there is a need to obtain a higher update rate, HWAAS\n could be decreased but this leads to lower SNR.\n\n HWAAS must be between 1 and 511 inclusive\n\n @param[in] config The config to set HWAAS for\n @param[in] hwaas Hardware accelerated average samples"]
    pub fn acc_config_hwaas_set(config: *mut acc_config_t, hwaas: u16);
}
extern "C" {
    #[doc = " @brief Get the hardware accelerated average samples (HWAAS)\n\n @see acc_config_hwaas_set\n\n @param[in] config The config to get HWAAS from\n @return Hardware accelerated average samples"]
    pub fn acc_config_hwaas_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set receiver gain setting\n\n Must be a value between 0 and 23 inclusive where 23 is the highest gain and 0 the lowest.\n\n Lower gain gives higher SNR. However, too low gain may result in quantization, lowering SNR.\n Too high gain may result in saturation, corrupting the data.\n\n @param[in] config The configuration\n @param[in] gain Receiver gain setting"]
    pub fn acc_config_receiver_gain_set(config: *mut acc_config_t, gain: u8);
}
extern "C" {
    #[doc = " @brief Get receiver gain setting\n\n See @ref acc_config_receiver_gain_set\n\n @param[in] config The configuration\n @return Receiver gain setting"]
    pub fn acc_config_receiver_gain_get(config: *const acc_config_t) -> u8;
}
extern "C" {
    #[doc = " @brief Set sweeps per frame\n\n Sets the number of sweeps that will be captured in each frame (measurement).\n Can be set to 0 if e.g. only temperature measurement is wanted.\n\n @param[in] config The configuration\n @param[in] sweeps Sweeps per frame"]
    pub fn acc_config_sweeps_per_frame_set(config: *mut acc_config_t, sweeps: u16);
}
extern "C" {
    #[doc = " @brief Get the number of sweeps per frame\n\n See @ref acc_config_sweeps_per_frame_set\n\n @param[in] config The configuration\n @return Sweeps per frame"]
    pub fn acc_config_sweeps_per_frame_get(config: *const acc_config_t) -> u16;
}
extern "C" {
    #[doc = " @brief Set the sweep rate\n\n Sets the sweep rate for sweeps in a frame (measurement).\n\n @param[in] config The configuration\n @param[in] sweep_rate Sweep rate in Hz. Must be >= 0, 0 is interpreted as max sweep rate"]
    pub fn acc_config_sweep_rate_set(config: *mut acc_config_t, sweep_rate: f32);
}
extern "C" {
    #[doc = " @brief Get the sweep rate\n\n See @ref acc_config_sweep_rate_set\n\n @param[in] config The configuration\n @return Sweep rate in Hz"]
    pub fn acc_config_sweep_rate_get(config: *const acc_config_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set continuous sweep mode\n\n In continuous sweep mode the timing will be identical over all sweeps, not\n just the sweeps in a frame.\n\n Constraints:\n - Frame rate must be set to unlimited (0.0)\n - Sweep rate must be set (> 0)\n - Inter frame idle state must be set equal to inter sweep idle state\n\n @param[in] config The configuration\n @param[in] enabled true if continuous sweep mode should be enabled, false otherwise"]
    pub fn acc_config_continuous_sweep_mode_set(config: *mut acc_config_t, enabled: bool);
}
extern "C" {
    #[doc = " @brief Get continuous sweep mode\n\n See @ref acc_config_continuous_sweep_mode_set\n\n @param[in] config The configuration\n @return true if continuous sweep mode is enabled, false otherwise"]
    pub fn acc_config_continuous_sweep_mode_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set the frame rate\n\n Sets the frame rate.\n\n Setting the frame rate to unlimited (0) means that the rate is not limited by the\n sensor but the rate that the host acknowledge and reads out the measurement data.\n\n @param[in] config The configuration\n @param[in] frame_rate Frame rate in Hz. Must be >= 0, 0 is interpreted as unlimited"]
    pub fn acc_config_frame_rate_set(config: *mut acc_config_t, frame_rate: f32);
}
extern "C" {
    #[doc = " @brief Get the frame rate\n\n See @ref acc_config_frame_rate_set\n\n @param[in] config The configuration\n @return Frame rate"]
    pub fn acc_config_frame_rate_get(config: *const acc_config_t) -> f32;
}
extern "C" {
    #[doc = " @brief Enable or disable the transmitter\n\n If set to true, TX is enabled. This will enable the radio transmitter.\n By turning the transmitter off the RX noise floor can be measured.\n\n @param[in] config The configuration\n @param[in] enable true to enable the transmitter, false to disable it"]
    pub fn acc_config_enable_tx_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get transmitter enable configuration\n\n See @ref acc_config_enable_tx_set\n\n @param[in] config The configuration\n @return true if the transmitter is enabled, false if it is disabled"]
    pub fn acc_config_enable_tx_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set inter frame idle state\n\n The 'inter-frame idle state' is the state the sensor idles in between each frame.\n\n See also @ref acc_config_idle_state_t.\n\n The inter frame idle state of the frame must be deeper or the same as the inter sweep idle state.\n\n @param[in] config The configuration\n @param[in] idle_state The idle state to use between frames"]
    pub fn acc_config_inter_frame_idle_state_set(
        config: *mut acc_config_t,
        idle_state: acc_config_idle_state_t,
    );
}
extern "C" {
    #[doc = " @brief Get inter frame idle state\n\n See @ref acc_config_inter_frame_idle_state_set\n\n @param[in] config The configuration\n @return The idle state to use between frames"]
    pub fn acc_config_inter_frame_idle_state_get(
        config: *const acc_config_t,
    ) -> acc_config_idle_state_t;
}
extern "C" {
    #[doc = " @brief Set inter sweep idle state\n\n The 'inter-sweep idle state' is the state the sensor idles in between each sweep in a frame.\n\n See also @ref acc_config_idle_state_t.\n\n @param[in] config The configuration\n @param[in] idle_state The idle state to use between sweeps within a frame"]
    pub fn acc_config_inter_sweep_idle_state_set(
        config: *mut acc_config_t,
        idle_state: acc_config_idle_state_t,
    );
}
extern "C" {
    #[doc = " @brief Get inter sweep idle state\n\n See @ref acc_config_inter_sweep_idle_state_set\n\n @param[in] config The configuration\n @return The idle state to use between sweeps within a frame"]
    pub fn acc_config_inter_sweep_idle_state_get(
        config: *const acc_config_t,
    ) -> acc_config_idle_state_t;
}
extern "C" {
    #[doc = " @brief Set Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @param[in] prf The Pulse Repetition Frequency to use"]
    pub fn acc_config_prf_set(config: *mut acc_config_t, prf: acc_config_prf_t);
}
extern "C" {
    #[doc = " @brief Get Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @return Pulse Repetition Frequency"]
    pub fn acc_config_prf_get(config: *const acc_config_t) -> acc_config_prf_t;
}
extern "C" {
    #[doc = " @brief Enable or disable phase enhancement\n\n If enabled, the data phase will be enhanced such that coherent distance filtering can be applied.\n Given a single reflection from an object, the phase will appear as \"flat\" around the amplitude peak.\n\n Enabling the phase enhancement increases the processing execution time.\n\n @param[in] config The configuration\n @param[in] enable true if phase enhancement should be enabled, false otherwise"]
    pub fn acc_config_phase_enhancement_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the phase enhancement configuration\n\n See @ref acc_config_phase_enhancement_set\n\n @param[in] config The configuration\n @return true if phase enhancement is enabled, false otherwise"]
    pub fn acc_config_phase_enhancement_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Enable or disable loopback\n\n Constraints:\n - Loopback can't be enabled together with profile 2.\n\n @param[in] config The configuration\n @param[in] enable true if loopback should be enabled, false otherwise"]
    pub fn acc_config_enable_loopback_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the enable loopback configuration\n\n See @ref acc_config_enable_loopback_set\n\n @param[in] config The configuration\n @return true if loopback is enabled, false otherwise"]
    pub fn acc_config_enable_loopback_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Enable or disable double buffering\n\n If enabled, the sensor buffer will be split in two halves reducing the\n maximum number of samples. A frame can be read using @ref acc_sensor_read while\n sampling is done into the other buffer. Switching of buffers is done automatically\n by @ref acc_sensor_measure.\n\n When using double buffering, measurements coinciding with SPI activity may have distorted phase.\n To mitigate this issue, applying a median filter is recommended.\n\n @param[in] config The configuration\n @param[in] enable true if double buffering should be enabled, false otherwise"]
    pub fn acc_config_double_buffering_set(config: *mut acc_config_t, enable: bool);
}
extern "C" {
    #[doc = " @brief Get the double buffering configuration\n\n See @ref acc_config_double_buffering_set\n\n @param[in] config The configuration\n @return true if double buffering is enabled, false otherwise"]
    pub fn acc_config_double_buffering_get(config: *const acc_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set the number of subsweeps to use\n\n @param[in] config The configuration\n @param[in] num_subsweeps The number of subsweeps"]
    pub fn acc_config_num_subsweeps_set(config: *mut acc_config_t, num_subsweeps: u8);
}
extern "C" {
    #[doc = " @brief Get the number of subsweeps to use\n\n @param[in] config The configuration\n @return The number of subsweeps"]
    pub fn acc_config_num_subsweeps_get(config: *const acc_config_t) -> u8;
}
extern "C" {
    #[doc = " @brief Set the starting point of the sweep\n\n See @ref acc_config_start_point_set\n\n @param[in] config The configuration\n @param[in] start_point The starting point of the sweep\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_start_point_set(
        config: *mut acc_config_t,
        start_point: i32,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the starting point of the sweep\n\n See @ref acc_config_start_point_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return The starting point of the sweep"]
    pub fn acc_config_subsweep_start_point_get(config: *const acc_config_t, index: u8) -> i32;
}
extern "C" {
    #[doc = " @brief Set the number of data points to measure\n\n See @ref acc_config_num_points_set\n\n @param[in] config The configuration\n @param[in] num_points Number of data points to measure\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_num_points_set(
        config: *mut acc_config_t,
        num_points: u16,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the number of data points to measure\n\n See @ref acc_config_num_points_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return Number of data points to measure"]
    pub fn acc_config_subsweep_num_points_get(config: *const acc_config_t, index: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Set the step length in a sweep\n\n See @ref acc_config_step_length_set\n\n @param[in] config The configuration\n @param[in] step_length The step length\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_step_length_set(
        config: *mut acc_config_t,
        step_length: u16,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the step length in a sweep\n\n See @ref acc_config_step_length_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return The step length"]
    pub fn acc_config_subsweep_step_length_get(config: *const acc_config_t, index: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Set a profile\n\n See @ref acc_config_profile_set\n\n @param[in] config The config to set a profile for\n @param[in] profile The profile to set\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_profile_set(
        config: *mut acc_config_t,
        profile: acc_config_profile_t,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the currently used profile\n\n See @ref acc_config_profile_get\n\n @param[in] config The config to get a profile for\n @param[in] index The subsweep index\n @return The current profile, 0 if config is invalid"]
    pub fn acc_config_subsweep_profile_get(
        config: *const acc_config_t,
        index: u8,
    ) -> acc_config_profile_t;
}
extern "C" {
    #[doc = " @brief Set the hardware accelerated average samples (HWAAS)\n\n See @ref acc_config_hwaas_set\n\n @param[in] config The config to set hwaas for\n @param[in] hwaas Hardware accelerated average samples\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_hwaas_set(config: *mut acc_config_t, hwaas: u16, index: u8);
}
extern "C" {
    #[doc = " @brief Get the hardware accelerated average samples (HWAAS)\n\n See @ref acc_config_hwaas_get\n\n @param[in] config The config to get hwaas from\n @param[in] index The subsweep index\n @return Hardware accelerated average samples"]
    pub fn acc_config_subsweep_hwaas_get(config: *const acc_config_t, index: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Set receiver gain setting\n\n See @ref acc_config_receiver_gain_set\n\n @param[in] config The configuration\n @param[in] gain Receiver gain setting\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_receiver_gain_set(config: *mut acc_config_t, gain: u8, index: u8);
}
extern "C" {
    #[doc = " @brief Get receiver gain setting\n\n See @ref acc_config_receiver_gain_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return Receiver gain setting"]
    pub fn acc_config_subsweep_receiver_gain_get(config: *const acc_config_t, index: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Enable or disable the transmitter\n\n See @ref acc_config_enable_tx_set\n\n @param[in] config The configuration\n @param[in] enable true to enable the transmitter\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_enable_tx_set(config: *mut acc_config_t, enable: bool, index: u8);
}
extern "C" {
    #[doc = " @brief Get transmitter enable mode\n\n See @ref acc_config_enable_tx_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return true if the transmitter is enabled"]
    pub fn acc_config_subsweep_enable_tx_get(config: *const acc_config_t, index: u8) -> bool;
}
extern "C" {
    #[doc = " @brief Set Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @param[in] prf The Pulse Repetition Frequency to use\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_prf_set(config: *mut acc_config_t, prf: acc_config_prf_t, index: u8);
}
extern "C" {
    #[doc = " @brief Get Pulse Repetition Frequency\n\n See @ref acc_config_prf_t for details.\n\n @param[in] config The configuration\n @return Pulse Repetition Frequency\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_prf_get(config: *const acc_config_t, index: u8) -> acc_config_prf_t;
}
extern "C" {
    #[doc = " @brief Set the phase enhancement enabled configuration\n\n See @ref acc_config_phase_enhancement_set\n\n @param[in] config The configuration\n @param[in] enable true if phase enhancement to be enabled, false otherwise\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_phase_enhancement_set(
        config: *mut acc_config_t,
        enable: bool,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the phase enhancement enabled configuration\n\n See @ref acc_config_phase_enhancement_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return true if phase enhancement is enabled, false otherwise"]
    pub fn acc_config_subsweep_phase_enhancement_get(
        config: *const acc_config_t,
        index: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the loopback enabled configuration\n\n See @ref acc_config_enable_loopback_set\n\n @param[in] config The configuration\n @param[in] enable true if loopback to be enabled, false otherwise\n @param[in] index The subsweep index"]
    pub fn acc_config_subsweep_enable_loopback_set(
        config: *mut acc_config_t,
        enable: bool,
        index: u8,
    );
}
extern "C" {
    #[doc = " @brief Get the enable loopback configuration\n\n See @ref acc_config_enable_loopback_get\n\n @param[in] config The configuration\n @param[in] index The subsweep index\n @return true if loopback is enabled, false otherwise"]
    pub fn acc_config_subsweep_enable_loopback_get(config: *const acc_config_t, index: u8) -> bool;
}
#[doc = " @brief Generic processing handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_processing_handle {
    _unused: [u8; 0],
}
pub type acc_processing_t = acc_processing_handle;
#[doc = " @brief Metadata that will be populated by the processing module during creation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_processing_metadata_t {
    #[doc = " Number of elements in the frame"]
    pub frame_data_length: u16,
    #[doc = " Number of elements in the sweep"]
    pub sweep_data_length: u16,
    #[doc = " Offset to the subsweeps data"]
    pub subsweep_data_offset: [u16; 4usize],
    #[doc = " Number of elements in the subsweeps"]
    pub subsweep_data_length: [u16; 4usize],
    #[doc = " Maximum sweep rate that the sensor can provide for the given configuration.\n  Note that this is not the actual exact sweep rate. To obtain an exact rate,\n  use the sweep rate parameter, @ref acc_config_sweep_rate_set.\n\n  If no max sweep rate is applicable, it's set to 0.0f."]
    pub max_sweep_rate: f32,
    #[doc = " Flag indicating if high speed mode is used.\n  If true, it means that the sensor has been configured in a way where it\n  can optimize its measurements and obtain a high max_sweep_rate.\n\n  Configuration limitations to enable high speed mode:\n\n  continuous_sweep_mode false, see @ref acc_config_continuous_sweep_mode_set\n  inter_sweep_idle_state READY, see @ref acc_config_inter_sweep_idle_state_set\n  num_subsweeps 1, see @ref acc_config_num_subsweeps_set\n  profile 3-5, see @ref acc_config_profile_set"]
    pub high_speed_mode: bool,
}
#[test]
fn bindgen_test_layout_acc_processing_metadata_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_processing_metadata_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_processing_metadata_t>(),
        28usize,
        concat!("Size of: ", stringify!(acc_processing_metadata_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_processing_metadata_t>(),
        4usize,
        concat!("Alignment of ", stringify!(acc_processing_metadata_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_data_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(frame_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sweep_data_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(sweep_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsweep_data_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(subsweep_data_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsweep_data_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(subsweep_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_sweep_rate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(max_sweep_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high_speed_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_metadata_t),
            "::",
            stringify!(high_speed_mode)
        )
    );
}
#[doc = " @brief Result provided by the processing module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_processing_result_t {
    #[doc = " Indication of sensor data being saturated, can cause data corruption.\n  Lower the receiver gain if this indication is set."]
    pub data_saturated: bool,
    #[doc = " Indication of a delayed frame.\n  The frame rate might need to be lowered if this indication is set."]
    pub frame_delayed: bool,
    #[doc = " Indication of calibration needed\n  The sensor calibration needs to be redone if this indication is set."]
    pub calibration_needed: bool,
    #[doc = " Temperature in sensor during measurement (in degree Celsius).\n  Note that it has poor absolute accuracy and should only be used\n  for relative temperature measurements."]
    pub temperature: i16,
    #[doc = " Pointer to the frame data"]
    pub frame: *mut acc_int16_complex_t,
}
#[test]
fn bindgen_test_layout_acc_processing_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_processing_result_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_processing_result_t>(),
        16usize,
        concat!("Size of: ", stringify!(acc_processing_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_processing_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(acc_processing_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_saturated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(data_saturated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_delayed) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(frame_delayed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calibration_needed) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(calibration_needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_processing_result_t),
            "::",
            stringify!(frame)
        )
    );
}
extern "C" {
    #[doc = " @brief Create a processing instance with the provided configuration\n\n @param[in] config The configuration to create a processing instance with\n @param[out] processing_metadata The metadata of the created processing instance\n @return Processing handle, NULL if processing instance was not possible to create"]
    pub fn acc_processing_create(
        config: *const acc_config_t,
        processing_metadata: *mut acc_processing_metadata_t,
    ) -> *mut acc_processing_t;
}
extern "C" {
    #[doc = " @brief Process the data according to the configuration used in create\n\n @param[in] handle  A reference to the processing handle\n @param[in] buffer  A reference to the buffer (populated by @ref acc_sensor_read) containing the\n                    data to be processed.\n\n @param[out] result Processing result"]
    pub fn acc_processing_execute(
        handle: *mut acc_processing_t,
        buffer: *mut cty::c_void,
        result: *mut acc_processing_result_t,
    );
}
extern "C" {
    #[doc = " @brief Destroy a processing instance identified with the provided processing handle\n\n @param[in] handle A reference to the processing handle to destroy, can be NULL"]
    pub fn acc_processing_destroy(handle: *mut acc_processing_t);
}
extern "C" {
    #[doc = " @brief Convert a distance or step length in points to meter\n\n Does not include any zero-point offset since it is highly integration dependant. In other words,\n calling this function with a 0 always returns 0.0.\n\n @param[in] points Number of points to convert to meter\n @return The corresponding length in meters"]
    pub fn acc_processing_points_to_meter(points: i32) -> f32;
}
extern "C" {
    #[doc = " @brief Convert a distance or step length in meter to points\n\n Does not include any zero-point offset since it is highly integration dependant. In other words,\n calling this function with a 0.0 always returns 0.\n\n @param[in] length Length in meter to convert to points\n @return The corresponding length in points"]
    pub fn acc_processing_meter_to_points(length: f32) -> i32;
}
#[doc = " @defgroup service Service\n\n @brief Service API\n\n @defgroup sensor Sensor\n @ingroup service\n\n @brief Module to control the sensor\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_sensor {
    _unused: [u8; 0],
}
pub type acc_sensor_t = acc_sensor;
extern "C" {
    #[doc = " @brief Create a sensor instance\n\n A sensor instance represents a physical radar sensor and handles the communication\n with it.\n\n Before this function is called the sensor must be powered on and not used\n in another sensor instance without a power or reset cycle between.\n\n @param[in] sensor_id The sensor id to be used to communicate with\n\n @return Sensor instance, NULL if sensor instance was not possible to create"]
    pub fn acc_sensor_create(sensor_id: acc_sensor_id_t) -> *mut acc_sensor_t;
}
extern "C" {
    #[doc = " @brief Destroy a sensor instance freeing any resources allocated.\n\n @param[in] sensor The sensor instance to destroy, can be NULL"]
    pub fn acc_sensor_destroy(sensor: *mut acc_sensor_t);
}
extern "C" {
    #[doc = " @brief Calibrate a sensor\n\n Note that the sensor must be powered on before calling this function.\n To calibrate the sensor, call this function and wait for sensor interrupt,\n repeat until calibration is complete (or fails).\n\n @param[in]  sensor The sensor instance to calibrate\n @param[out] cal_complete True if calibration is complete\nFalse if caller should wait for interrupt and\nthen call again\n @param[out] cal_result The result after a completed calibration\n @param[in]  buffer Memory used during calibration.\n             A larger buffer might mean fewer transactions between host and sensor.\n             The buffer will only be used during the calibration.\n             The client has to make sure this buffer is suitably aligned for\n             any built-in type.\n @param[in]  buffer_size The size in bytes of the buffer, should be at least buffer_size\nfrom @ref acc_rss_get_buffer_size\n @return true if successful, false otherwise"]
    pub fn acc_sensor_calibrate(
        sensor: *mut acc_sensor_t,
        cal_complete: *mut bool,
        cal_result: *mut acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Gets calibration information from a calibration result\n\n @param[in]  cal_result The calibration result\n @param[out] cal_info The calibration information\n @return true if successful, false otherwise"]
    pub fn acc_sensor_get_cal_info(
        cal_result: *const acc_cal_result_t,
        cal_info: *mut acc_cal_info_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Prepare a sensor to do a measurement\n\n It's possible to reconfigure the sensor by calling the function multiple times.\n\n Note:\n - The sensor must be powered on when calling this function.\n - The sensor must not be measuring when calling this function, if previous call was\n   @ref acc_sensor_measure use @ref acc_hal_integration_wait_for_sensor_interrupt to\n   wait for measurement to complete.\n - Reconfiguring is not supported when double buffering is active, however enabling\n   double buffering through reconfiguration is.\n\n @param[in] sensor The sensor instance to prepare\n @param[in] config The configuration to prepare for\n @param[in] cal_result The calibration result to prepare for\n @param[in] buffer Memory used during preparation.\n            A larger buffer might mean fewer transactions between host and sensor.\n            The buffer will only be used during the duration of this call.\n            The client has to make sure this buffer is suitably aligned for\n            any built-in type.\n @param[in] buffer_size The size in bytes of the buffer, should be at least buffer_size\n            from @ref acc_rss_get_buffer_size\n @return true if successful, false otherwise"]
    pub fn acc_sensor_prepare(
        sensor: *mut acc_sensor_t,
        config: *const acc_config_t,
        cal_result: *const acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Start a radar measurement with previously prepared configuration\n\n Note that the following preconditions apply\n  - The sensor must be powered on\n  - @ref acc_sensor_calibrate must have been called\n  - @ref acc_sensor_prepare must have been called\n\n @param[in] sensor The sensor instance to measure with\n @return true if successful, false otherwise"]
    pub fn acc_sensor_measure(sensor: *mut acc_sensor_t) -> bool;
}
extern "C" {
    #[doc = " @brief Read out radar data\n\n Note that the following preconditions apply\n  - The sensor must be powered on\n  - @ref acc_sensor_measure must be called before each call to this function\n  - The sensor interrupt must be active\n\n @param[in] sensor The sensor to read the radar data from\n @param[in] buffer The buffer to read radar data into.\n            The buffer will only be used during the duration of this call.\n            The client has to make sure this buffer is suitably aligned for\n            any built-in type.\n @param[in] buffer_size The size in bytes of the buffer, should be at least buffer_size\n            from @ref acc_rss_get_buffer_size\n @return true if successful, false otherwise"]
    pub fn acc_sensor_read(
        sensor: *const acc_sensor_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if a sensor is connected and responsive\n\n Note that the sensor must be powered on before calling this function.\n\n @param[in] sensor_id The sensor id to be used to communicate with\n @return true if it is possible to communicate with the sensor"]
    pub fn acc_sensor_connected(sensor_id: acc_sensor_id_t) -> bool;
}
extern "C" {
    #[doc = " @brief Check the status of the sensor\n\n This function reads out the internal status from the sensor and prints it for debugging purposes.\n It can for example be called when the function @ref acc_hal_integration_wait_for_sensor_interrupt()\n fails. Note that the sensor must be powered on before calling this function.\n\n @param[in] sensor The sensor instance to get status from"]
    pub fn acc_sensor_status(sensor: *const acc_sensor_t);
}
extern "C" {
    #[doc = " @brief Prepare sensor for entering hibernation\n\n Prepare sensor for entering hibernation.\n Should be invoked prior to calling @ref acc_hal_integration_sensor_disable()\n\n @param[in] sensor The sensor to prepare for hibernation\n @return True if prepare was successful"]
    pub fn acc_sensor_hibernate_on(sensor: *mut acc_sensor_t) -> bool;
}
extern "C" {
    #[doc = " @brief Restore sensor after exiting hibernation\n\n Restore sensor after exiting hibernation.\n Should be invoked after calling @ref acc_hal_integration_sensor_enable()\n\n @param[in] sensor The sensor to unprepare for hibernation\n @return True if unprepare was successful"]
    pub fn acc_sensor_hibernate_off(sensor: *const acc_sensor_t) -> bool;
}
extern "C" {
    #[doc = " @brief Validate calibration result\n\n @param[in] cal_result Result of a calibration\n\n @return True if calibration is valid"]
    pub fn acc_sensor_validate_calibration(cal_result: *const acc_cal_result_t) -> bool;
}
#[doc = " @brief Distance detector handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_detector_distance_handle {
    _unused: [u8; 0],
}
pub type acc_detector_distance_handle_t = acc_detector_distance_handle;
#[doc = " @brief Configuration of the distance detector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_detector_distance_config {
    _unused: [u8; 0],
}
pub type acc_detector_distance_config_t = acc_detector_distance_config;
#[doc = " @brief Distance detector result"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acc_detector_distance_result_t {
    #[doc = " The detected distances in meters"]
    pub distances: [f32; 10usize],
    #[doc = " The reflective strengths of each distance"]
    pub strengths: [f32; 10usize],
    #[doc = " The number of detected distances. If 0, no distances where detected"]
    pub num_distances: u8,
    #[doc = " Indicating that there might be an object near the start point of the measured range"]
    pub near_start_edge_status: bool,
    #[doc = " Indication of sensor calibration needed. The sensor calibration needs to be redone\n if this indication is set.\n\n A sensor calibration should be followed by a detector recalibration, by calling\n @ref acc_detector_distance_recalibrate."]
    pub sensor_calibration_needed: bool,
    #[doc = " Temperature in sensor during measurement (in degree Celsius).\n  Note that it has poor absolute accuracy and should only be used\n  for relative temperature measurements."]
    pub temperature: i16,
    #[doc = " Radar data that the distance detection is based on.\n This will point to memory in the buffer supplied to @ref acc_detector_distance_process\n\n Note: The processing result is only valid until the next time\n        @ref acc_detector_distance_process is called."]
    pub processing_result: *mut acc_processing_result_t,
    #[doc = " The metadata for the processing result\n\n Note: The processing metedata is only valid until the next time\n        @ref acc_detector_distance_process is called."]
    pub processing_metadata: *mut acc_processing_metadata_t,
    #[doc = " The sensor_config used for the processing result\n\n Note: The sensor_config is only valid until the next time\n        @ref acc_detector_distance_process is called."]
    pub sensor_config: *const acc_config_t,
}
#[test]
fn bindgen_test_layout_acc_detector_distance_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<acc_detector_distance_result_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<acc_detector_distance_result_t>(),
        112usize,
        concat!("Size of: ", stringify!(acc_detector_distance_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<acc_detector_distance_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(acc_detector_distance_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).distances) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(distances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strengths) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(strengths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_distances) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(num_distances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).near_start_edge_status) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(near_start_edge_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensor_calibration_needed) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(sensor_calibration_needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).processing_result) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(processing_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).processing_metadata) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(processing_metadata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensor_config) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(acc_detector_distance_result_t),
            "::",
            stringify!(sensor_config)
        )
    );
}
extern "C" {
    #[doc = " @brief Create a configuration for a distance detector\n\n @return Distance detector configuration, NULL in case of error"]
    pub fn acc_detector_distance_config_create() -> *mut acc_detector_distance_config_t;
}
extern "C" {
    #[doc = " @brief Destroy a configuration for a distance detector\n\n @param[in] config The configuration to destroy"]
    pub fn acc_detector_distance_config_destroy(config: *mut acc_detector_distance_config_t);
}
extern "C" {
    #[doc = " @brief Print a configuration to the log\n\n @param[in] handle The distance detector handle, if NULL only distance config will be logged\n @param[in] config The configuration to log"]
    pub fn acc_detector_distance_config_log(
        handle: *const acc_detector_distance_handle_t,
        config: *const acc_detector_distance_config_t,
    );
}
extern "C" {
    #[doc = " @brief Get the buffer sizes needed given the provided detector handle\n\n buffer_size is memory needed by the detector for calculations. This memory can be\n reused between instances.\n calibration_buffer_size is memory needed to calibrate the detector. This memory\n needs to be persistent for a single instance of the detector.\n\n @param[in] handle The distance detector handle\n @param[out] buffer_size The buffer size\n @param[out] calibration_buffer_size The calibration buffer size\n @return true if successful, false otherwise"]
    pub fn acc_detector_distance_get_buffer_sizes(
        handle: *const acc_detector_distance_handle_t,
        buffer_size: *mut u32,
        calibration_buffer_size: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Create a distance detector with the provided configuration\n\n @param[in] config The configuration to create a distance detector with\n @return Distance detector handle, NULL if distance detector was not possible to create"]
    pub fn acc_detector_distance_create(
        config: *const acc_detector_distance_config_t,
    ) -> *mut acc_detector_distance_handle_t;
}
extern "C" {
    #[doc = " @brief Destroy the distance detector handle, freeing its resources\n\n @param[in] handle The handle to destroy"]
    pub fn acc_detector_distance_destroy(handle: *mut acc_detector_distance_handle_t);
}
extern "C" {
    #[doc = " @brief Do a detector calibration\n\n The calibrations done are dependant on what configuration is used.\n E.g. A detector configuration with a fixed threshold will not need to record the background\n\n Note: The calibration_buffer cannot be modified\n       after being populated by this function\n\n @param[in] sensor The sensor instance to use for calibration\n @param[in] handle The detector handle\n @param[in] sensor_cal_result Sensor calibration result\n @param[in] buffer The buffer\n @param[in] buffer_size The size of buffer. Needs to be at least\n            the result of @ref acc_detector_distance_get_buffer_sizes\n @param[out] calibration_buffer The buffer will be populated with calibration data\n @param[in] calibration_buffer_size The size of buffer. Needs to be at least\n            the result of @ref acc_detector_distance_get_buffer_sizes\n @param[out] calibration_complete Will be set to true when the calibration is complete.\n             If false; at least one more call to this function is needed.\n             Note that it's necessary to wait for interrupt between calls.\n @return true if successful, false otherwise"]
    pub fn acc_detector_distance_calibrate(
        sensor: *mut acc_sensor_t,
        handle: *mut acc_detector_distance_handle_t,
        sensor_cal_result: *const acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
        calibration_buffer: *mut cty::c_void,
        calibration_buffer_size: u32,
        calibration_complete: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Do a detector recalibration\n\n This function should only be used if sensor is recalibrated after initial detector\n calibration.\n\n Note: The calibration_buffer cannot be modified\n       after being populated by this function\n\n @param[in] sensor The sensor instance to use for calibration\n @param[in] handle The detector handle\n @param[in] sensor_cal_result Sensor calibration result\n @param[in] buffer The buffer\n @param[in] buffer_size The size of buffer. Needs to be at least\n            the result of @ref acc_detector_distance_get_buffer_sizes\n @param[out] calibration_buffer The buffer will be populated with calibration data\n @param[in] calibration_buffer_size The size of buffer. Needs to be at least\n            the result of @ref acc_detector_distance_get_buffer_sizes\n @param[out] calibration_complete Will be set to true when the calibration is complete.\n             If false; at least one more call to this function is needed.\n             Note that it's necessary to wait for interrupt between calls.\n @return true if successful, false otherwise"]
    pub fn acc_detector_distance_recalibrate(
        sensor: *mut acc_sensor_t,
        handle: *mut acc_detector_distance_handle_t,
        sensor_cal_result: *const acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
        calibration_buffer: *mut cty::c_void,
        calibration_buffer_size: u32,
        calibration_complete: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Prepare the detector for measurements\n\n This should to be done before every measure/wait for interrupt/read, as it reconfigures the sensor.\n\n @param[in, out] handle The distance detector handle\n @param[in] config The distance detector config\n @param[in] sensor The sensor instance to prepare\n @param[in] sensor_cal_result The sensor calibration result to prepare with\n @param[in] buffer Memory used by the detector. Should be at least buffer_size bytes\n @param[in] buffer_size The buffer size received by @ref acc_detector_distance_get_buffer_sizes\n @return true if successful, false otherwise"]
    pub fn acc_detector_distance_prepare(
        handle: *const acc_detector_distance_handle_t,
        config: *const acc_detector_distance_config_t,
        sensor: *mut acc_sensor_t,
        sensor_cal_result: *const acc_cal_result_t,
        buffer: *mut cty::c_void,
        buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Process the data according to the configuration used in @ref acc_detector_distance_config_create\n\n @param[in] handle The distance detector handle\n @param[in] buffer A reference to the buffer (populated by @ref acc_sensor_read) containing the\n                    data to be processed.\n @param[in] calibration_buffer The buffer containing results from @ref acc_detector_distance_calibrate\n @param[out] result_available Whether result will contain a new result\n @param[out] result Distance detector result\n @return true if successful, false otherwise"]
    pub fn acc_detector_distance_process(
        handle: *mut acc_detector_distance_handle_t,
        buffer: *mut cty::c_void,
        calibration_buffer: *mut cty::c_void,
        result_available: *mut bool,
        result: *mut acc_detector_distance_result_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the sensor ID\n\n @param[out] config The distance detector config\n @param[in] sensor Sensor ID"]
    pub fn acc_detector_distance_config_sensor_set(
        config: *mut acc_detector_distance_config_t,
        sensor: acc_sensor_id_t,
    );
}
extern "C" {
    #[doc = " @brief Get the sensor ID\n\n @param[in] config The distance detector config\n @return Sensor ID"]
    pub fn acc_detector_distance_config_sensor_get(
        config: *const acc_detector_distance_config_t,
    ) -> acc_sensor_id_t;
}
extern "C" {
    #[doc = " @brief Set the start of measured interval in meters.\n\n @param[out] config The distance detector config\n @param[in] start_m Starting point in meters."]
    pub fn acc_detector_distance_config_start_set(
        config: *mut acc_detector_distance_config_t,
        start_m: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the start of measured interval in meters.\n\n @param[in] config The distance detector config\n @return the start point in meters"]
    pub fn acc_detector_distance_config_start_get(
        config: *const acc_detector_distance_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the end of measured interval in meters.\n\n @param[out] config The distance detector config\n @param[in] end_m End point in meters."]
    pub fn acc_detector_distance_config_end_set(
        config: *mut acc_detector_distance_config_t,
        end_m: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the end of measured interval in meters.\n\n @param[in] config The distance detector config\n @return the end point in meters"]
    pub fn acc_detector_distance_config_end_get(
        config: *const acc_detector_distance_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the maximum step length\n\n Used to limit step length. If set to 0 (default), the step length is calculated\n based on profile.\n\n @param[out] config The distance detector config\n @param[in] max_step_length The maximum step length"]
    pub fn acc_detector_distance_config_max_step_length_set(
        config: *mut acc_detector_distance_config_t,
        max_step_length: u16,
    );
}
extern "C" {
    #[doc = " @brief Get the maximum step length\n\n @param[in] config The distance detector config\n @return the maximum step length"]
    pub fn acc_detector_distance_config_max_step_length_get(
        config: *const acc_detector_distance_config_t,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Enable the close range leakage cancellation logic\n\n Close range leakage cancellation refers to the process of measuring close to the\n sensor(<100mm) by first characterizing the direct leakage, and then subtracting it\n from the measured sweep in order to isolate the signal component of interest.\n The close range leakage cancellation process requires the sensor to be installed in its\n intended geometry with free space in front of the sensor during detector calibration.\n\n @param[out] config The distance detector config\n @param[in] enable true to enable close range leakage cancellation logic, false to disable"]
    pub fn acc_detector_distance_config_close_range_leakage_cancellation_set(
        config: *mut acc_detector_distance_config_t,
        enable: bool,
    );
}
extern "C" {
    #[doc = " @brief Get if the close range leakage cancellation logic is enabled\n\n @param[in] config The distance detector config\n @return true if close range leakage cancellation logic is enabled, false if disabled"]
    pub fn acc_detector_distance_config_close_range_leakage_cancellation_get(
        config: *const acc_detector_distance_config_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the signal quality\n\n High signal quality results in a better SNR (because of higher HWAAS) and higher power consumption.\n Signal quality can be set within the interval [-10, 35].\n\n @param[out] config The distance detector config\n @param[in] signal_quality The signal quality"]
    pub fn acc_detector_distance_config_signal_quality_set(
        config: *mut acc_detector_distance_config_t,
        signal_quality: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the signal quality\n\n @param[in] config The distance detector config\n @return the signal quality"]
    pub fn acc_detector_distance_config_signal_quality_get(
        config: *const acc_detector_distance_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the max profile\n\n Specifies the highest allowed profile (the default is the highest, Profile 5).\n A higher profile yields better SNR but worse distance resolution.\n\n @param[out] config The distance detector config\n @param[in] max_profile The max profile"]
    pub fn acc_detector_distance_config_max_profile_set(
        config: *mut acc_detector_distance_config_t,
        max_profile: acc_config_profile_t,
    );
}
extern "C" {
    #[doc = " @brief Get the max profile\n\n @param[in] config The distance detector config\n @return the max profile"]
    pub fn acc_detector_distance_config_max_profile_get(
        config: *const acc_detector_distance_config_t,
    ) -> acc_config_profile_t;
}
extern "C" {
    #[doc = " @brief Set the threshold method\n\n See @ref acc_detector_distance_threshold_method_t for details\n\n @param[out] config The distance detector config\n @param[in] threshold_method The threshold method"]
    pub fn acc_detector_distance_config_threshold_method_set(
        config: *mut acc_detector_distance_config_t,
        threshold_method: acc_detector_distance_threshold_method_t,
    );
}
extern "C" {
    #[doc = " @brief Get the threshold method\n\n @param[in] config The distance detector config\n @return the threshold method"]
    pub fn acc_detector_distance_config_threshold_method_get(
        config: *const acc_detector_distance_config_t,
    ) -> acc_detector_distance_threshold_method_t;
}
extern "C" {
    #[doc = " @brief Set the peak sorting method\n\n See @ref acc_detector_distance_peak_sorting_t for details\n\n @param[out] config The distance detector config\n @param[in] peak_sorting The peak sorting method"]
    pub fn acc_detector_distance_config_peak_sorting_set(
        config: *mut acc_detector_distance_config_t,
        peak_sorting: acc_detector_distance_peak_sorting_t,
    );
}
extern "C" {
    #[doc = " @brief Get the peak sorting method\n\n See @ref acc_detector_distance_config_peak_sorting_set\n\n @param[in] config The distance detector config\n @return The peak sorting method"]
    pub fn acc_detector_distance_config_peak_sorting_get(
        config: *const acc_detector_distance_config_t,
    ) -> acc_detector_distance_peak_sorting_t;
}
extern "C" {
    #[doc = " @brief Set the number frames to use for recorded threshold\n\n @param[out] config The distance detector config\n @param[in] num_frames Number of frames"]
    pub fn acc_detector_distance_config_num_frames_recorded_threshold_set(
        config: *mut acc_detector_distance_config_t,
        num_frames: u16,
    );
}
extern "C" {
    #[doc = " @brief Get the number of frames to use for recorded threshold\n\n @param[in] config The distance detector config\n @return Number of frames"]
    pub fn acc_detector_distance_config_num_frames_recorded_threshold_get(
        config: *const acc_detector_distance_config_t,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Set fixed amplitude threshold value\n\n This value is used when the threshold method is set to @ref ACC_DETECTOR_DISTANCE_THRESHOLD_METHOD_FIXED_AMPLITUDE\n\n @param[out] config The distance detector config\n @param[in] fixed_threshold_value The fixed threshold value"]
    pub fn acc_detector_distance_config_fixed_amplitude_threshold_value_set(
        config: *mut acc_detector_distance_config_t,
        fixed_threshold_value: f32,
    );
}
extern "C" {
    #[doc = " @brief Get fixed amplitude threshold value\n\n See @ref acc_detector_distance_config_fixed_amplitude_threshold_value_set\n\n @param[in] config The distance detector config\n @return The fixed threshold value"]
    pub fn acc_detector_distance_config_fixed_amplitude_threshold_value_get(
        config: *const acc_detector_distance_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set fixed strength threshold value\n\n This value is used when the threshold method is set to @ref ACC_DETECTOR_DISTANCE_THRESHOLD_METHOD_FIXED_STRENGTH\n\n @param[out] config The distance detector config\n @param[in] fixed_threshold_value The fixed threshold value"]
    pub fn acc_detector_distance_config_fixed_strength_threshold_value_set(
        config: *mut acc_detector_distance_config_t,
        fixed_threshold_value: f32,
    );
}
extern "C" {
    #[doc = " @brief Get fixed strength threshold value\n\n See @ref acc_detector_distance_config_fixed_strength_threshold_value_set\n\n @param[in] config The distance detector config\n @return The fixed threshold value"]
    pub fn acc_detector_distance_config_fixed_strength_threshold_value_get(
        config: *const acc_detector_distance_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set threshold sensitivity\n\n High sensitivity yields a low detection threshold, low sensitivity yields a high detection threshold.\n Threshold sensitivity can be set within the interval [0, 1].\n\n @param[out] config The distance detector config\n @param[in] threshold_sensitivity The threshold sensitivity"]
    pub fn acc_detector_distance_config_threshold_sensitivity_set(
        config: *mut acc_detector_distance_config_t,
        threshold_sensitivity: f32,
    );
}
extern "C" {
    #[doc = " @brief Get threshold sensitivity\n\n @param[in] config The distance detector config\n @return The threshold sensitivity"]
    pub fn acc_detector_distance_config_threshold_sensitivity_get(
        config: *const acc_detector_distance_config_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set reflector shape\n\n @param[out] config The distance detector config\n @param[in] reflector_shape The reflector shape"]
    pub fn acc_detector_distance_config_reflector_shape_set(
        config: *mut acc_detector_distance_config_t,
        reflector_shape: acc_detector_distance_reflector_shape_t,
    );
}
extern "C" {
    #[doc = " @brief Get reflector shape\n\n @param[in] config The distance detector config\n @return The reflector shape"]
    pub fn acc_detector_distance_config_reflector_shape_get(
        config: *const acc_detector_distance_config_t,
    ) -> acc_detector_distance_reflector_shape_t;
}
